\subsubsection{Base funtionalities} \mbox{}\\ \label{par:todo_app_inherited_widget_introduction} 
 
As mentioned in the Chapter XX RIFERIMENTO the mobx package makes part of the state Observable and uses a particular widget called Observer to keep track of the changes of the observable variables. In order to be able to define observable parts is necessary to extend the class containing them with the Store class offedered by the package. Moreover the container class must be made abstract. The usual definition of the Todo class is used for the moment remembering that no rendering optimization is kept into account. The parts of the state to be made observable are the list of todos , the filter and the tab value. The whole application indeed relies on them to track changes and update correspondingly. 
\paragraph{The observable state - }
\label{subpar:todo_app_bloc_core_state} A new abstract class is created and called TodoStore. It contains the list of todos and the filter. A separate observable variable will be used to implement the state of the tab. This design choice allows to show two different approaches the mobx package provides and divides the information regarding the todos from the information regarding the tab value. ( the filter value is in some way connected with the list of todo). This new abstract class is extended with the Store class. A list of todos and a visibility filter are created inside it and annoted with the @observable annotation. The annotation informs the code generator that those variables need to be observable and the code generator automatically creates a getter and a setter action for them. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
abstract class _TodoStore with Store {
  @observable
  List<Todo> todos = [];

  @observable
  VisibilityFilter filter = VisibilityFilter.all;
}
\end{minted}
\mbox{}
\end{code}

\paragraph{Actions - }
\label{subpar:todo_app_bloc_core_state}In this implementation the strict mode mobx provides is set to “always”. This choice reflects the common usage of the pattern. It is indeed a common choice to allow the state mutation only through actions. This behavior comes with a lot of advantages that make it the correct choice for the 99\% of the cases. This subject will be deeper investigated in the latter sections but, for the moment , it is worth noting that the mobx package also provides the possibility to configure the strict mode to “never” not allowing to directly change the state without passing through an action.  A bunch of new methods are added to the TodoStore class and marked with the @action annotation. The simplest one is the changeFilter method that allows to change the current filter.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart} 
 @action
  void changeFilter(VisibilityFilter filter) {
    this.filter = filter;
  }
\end{minted}
\mbox{}
\end{code}
A method to set the completed field of a particular todo is also required. This method is called setCompleted and takes the id of the todo to be changed and its new completed value. As usual , a new list is created after modifying the todo in order to allow mobx to recognize the change in the list of todos.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@action
  void setCompleted(int id, bool completed) {
    assert(todoExists(id) != null, 'No todo with id : \$id');
    todos = todos.map((element) {
      if (element.id == id) {
        return Todo(
            completed: completed,
            description: element.description,
            name: element.name,
            id: element.id);
      } else {
        return element;
      }
    }).toList();
  }


Todo? todoExists(int id) {
  List<Todo> result = todos.where((element) => element.id == id).toList();
  return result.isNotEmpty ? result.first : null;
}
\end{minted}
\mbox{}
\end{code}

The two usual methods to fetch and save the todos into the DataBase/repository are implemented and annotated with the @action annotation.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@action
Future<void> fetchTodos() async {
  todos = await TodoRepository.loadTodos();
}

@action
Future<void> saveTodos() async {
  await TodoRepository.saveTodos(todos);
}
\end{minted}
\mbox{}
\end{code}

\paragraph{Computed fields - }
\label{subpar:todo_app_bloc_core_state}computed fields are part of the state derived from other parts of the state. They are a pivotal point in the mobx state management because the package is able to smartly compute them and performs  lot of optimizations under the hood and uses memoization technique to prevent useless computations. They are a similar concept with respect to selector in Redux. The list of completed todos is well suited to demonstrate the power of the computed field. A new getter function is created and called completedTodos. It computes the list of completed todos and returns it. The @computed annotation is positioned right above the method to make the code generator know how to implement it in order to perform the optimizations discussed earlier. During the application lifecycle the completedTodos method will be accessed numerous times and automatically recomputed in case a part of the state ,it depends on, changes. Moreover, its value is memoized and reused in case multiple accesses are necessary. Another method is created in the same way to compute the pendingTodos.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@computed
List<Todo> get completedTodos =>
    todos.where((element) => element.completed).toList();

@computed
List<Todo> get pendingTodos =>
    todos.where((element) => !element.completed).toList();
\end{minted}
\mbox{}
\end{code}


pendingTodos and completedTodos methods are then used to implement another computed values, the filteredTodos, the number of completed todos and the number of pending todos. The filteredTodos method returns the list of todos that match the visibility filter. It is composed using the computed values defined before. Also the stats value can be obtained using the computed feature.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@computed
List<Todo> get filteredTodos {
  switch (filter) {
    case VisibilityFilter.all:
      return todos;
    case VisibilityFilter.completed:
      return todos.where((element) => element.completed).toList();
    case VisibilityFilter.notCompleted:
      return todos.where((element) => !element.completed).toList();
  }
}

@computed
int get len => todos.length;

@computed
int get completed => completedTodos.length;

@computed
int get pending => pendingTodos.length;

@computed
String get stats {
  return completed.toString();
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The code generation - }
\label{subpar:todo_app_bloc_core_state}The \_TodoStore class won’t be directly used in the code, its actual implementation instead will. The _TodoStore is indeed an abstract class and is used by the code generator to generate the actual TodoStore class. A particular line of code must be placed just below the imports to allow the code generator to . The generated code will be inside the part file: counter.g.dart, which isd included with the part directive right below the imports. Without this, the code generator will not produce any output. The generated file contains the _\$TodoStore mixin used with the _TodoStore abstract class to finally implement the TodoStore.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
part 'todo_store.g.dart';

class TodoStore = _TodoStore with _\$TodoStore;
\end{minted}
\mbox{}
\end{code}

In order to generate the code, a series of directives can be used into the terminal. For the sake of simplicity, the following line of code is always used.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
flutter pub run build_runner watch --delete-conflicting-outputs
\end{minted}
\mbox{}
\end{code}

It automatically generate the code and handles all the possible conflicts that can arise. For example, in case a file named todo\_store.g.dart already exists it first deletes the file and then computes it again. With this line of code, the code generation process is made really easy. The drawback is that every time the generated code must be modified it is generated from scratch instead. In our case is not a big deal because the application is contained and the code generator only takes about 12-13 seconds to execute and generate the entire code. In a more spread scenario other directives can be used to make the code generation process lighter. I decided not to show the generated code because it is quite long and hard to read.

\paragraph{The spy feature - }
\label{subpar:todo_app_bloc_core_state} in order to enable the spy feature a new configuration for the mainContext must be provided before running the application in the main function. After cloning the default mainContext the isSpyEnabled field is set to true and the writePolicy is set to always in order to enable the strict-mode for every state change. Moreover, a function is passed to the spy feature where is possible to perform arbitrary actions when events occurs. In our case is enough to print the event name when an event of type action occurs to have a clearer picture of what is going on.

\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
mainContext.config = mainContext.config
    .clone(isSpyEnabled: true, writePolicy: ReactiveWritePolicy.always);
mainContext.spy((event) {
  if (event.type == "action") {
    print("event name : " + event.name);
  }
});
\end{minted}
\mbox{}
\end{code}


And that’s basically all we need in order to implement the application’s state. At this point is indeed already possible to test the state logic.

\paragraph{Making the state accessible - }
\label{subpar:todo_app_bloc_core_state} MobX ,like every other solution used so far ,uses a provider widget to supply the state to the subtree. In this case the mobx package do not self-implement the provider widget, instead it relies on and external package called Provider which offers this feature. The procedure is the usual one, the MaterialApp widget is wrapped into a Provider widget of type TodoStore which supplies the instance of the TodoStore to the subtree. It has a create field where the TodoStore can be initialized and where the fetching of the todos can take place.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
return Provider<TodoStore>(
    create: (_) => TodoStore()..fetchTodos(),
    child: MaterialApp(. . .),
    }));
\end{minted}
\mbox{}
\end{code}



\paragraph{The HomePage and the TabSelector component - }
\label{subpar:todo_app_bloc_core_state}The HomePage is almost entirely build using the state part regarding the tab. The first thing to do is to create an observable variable of type TabState to represent it. This time a different approach with respect to the one used to implement the state of the todos and the filter is used. We are not creating an abstract class neither generating any code. Moreover, no Provider widget is used because the tab value needs to be accessed only in a couple of widgets and passing it between them is way easier. The tab value is wrapped into an observable object of type TabState. The entire object is managed by the mobx package and the only difference with respect to a normal variable is that in order to access the TabState value we need to further dig into the value field instead of just using the tab variable as it is. Both the body and the visibility filter component as well as the TabSelector depends on the tab value so the entire Scaffold widget is wrapped into a Observer widget. Once a change in the tab variable occurs the Observer widget automatically determine which parts of the scaffold widget to rebuild. In our case all components depends on the tab value and then every component is rebuild once a tab change occurs, but in case some component were independent by the tab value and wrapped into the observer widget it would not be rebuilt. The entire Scaffold is populated using the tab variable as usual, the only part that differs is the TabSelector component. Beside depending on the tab value it also need to change it. There are two equivalent options : passing the tab variable to the TabSelector component or passing a closure function that changed the tab variable. The first solution is used. A new variable is added to the TabSelector widget and populated in the constructor. It is used in the onTap field’s function to mutate its value once the user taps on one specific BottomNavigationBarItem. Notice that the state change is wrapped into a runInAction object. This because if we just change the tab value directly, a run time error would arise alerting that observable values cannot be changed outside actions. This is due to the strict mode previously set. runInAction creates a throwaway action we can use directly in the code. This approach is made necessary because we used a stand alone Observable variable. If we included the tab variable into the TodoStore class the code generator would had automatically create also its getter and setter actions.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class HomePage extends StatelessWidget {
  HomePage({Key? key}) : super(key: key);
  final _tab = Observable<TabState>(TabState.todos);

  @override
  Widget build(BuildContext context) {
    print("building HomePage");
    return Observer(
      builder: (context) {
        return Scaffold(
          appBar: AppBar(. . .),
          body: _tab.value == TabState.todos ? const TodoView() : const Stats(),
          bottomNavigationBar: TabSelector(
            tab: _tab,
          ),
          floatingActionButton:  _tab.value == TabState.todos
                ? FloatingActionButton(. . .)
                : Container()

        );
      }
    );
  }
}
\end{minted}
\mbox{}
\end{code}

\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}

class TabSelector extends StatelessWidget {
  final Observable<TabState> tab;

  const TabSelector({Key? key, required this.tab}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    print("building TabSelector");

      return BottomNavigationBar(
        currentIndex: TabState.values.indexOf(tab.value),
        onTap: (index) {
          runInAction(() => tab.value = TabState.values.elementAt(index));
        },
        items: TabState.values
            .map((tab) => BottomNavigationBarItem(...))
            .toList(),
      );

  }
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The VisibilityFilterSelector component - }
\label{subpar:todo_app_bloc_core_state}It entirely depends on the value of the filter in the TodoStore. To obtain the instance of the TodoStore we use the static of method of the Provider widget specifying the type of the instance we are looking for. This procedure will be frequently used from now on and is usually performed at the beginning of the build method. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final store = Provider.of<TodoStore>(context);
\end{minted}
\mbox{}
\end{code}

The entire VisibilityFilterSelector component is then populated using the filter  variable contained in the TodoStore as usual and wrapped into an Observer widget to make is responsive to filter changes. In the onChanged field of the DropdownMenuItem widgets the action changeFilter previously defined is used to
Set the filter value to the tapped one.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
return Observer(
  builder: (context) {
    print("building Visibilityfilter");

    return DropdownButton<VisibilityFilter>(
      value: store.filter,
      items: VisibilityFilter.values.map((filter) {
        return DropdownMenuItem<VisibilityFilter>(…);}).toList(),
      onChanged: (tappedValue) {
        store.changeFilter(tappedValue!);
      },
    );
  },
);
\end{minted}
\mbox{}
\end{code}

Notice that we could omit the usage of the changeFilter action and set the value of the filter directly. This because a setter and a getter action are automatically created by the code generator for every observable field. This implies that the changeFilter action could also be omitted in the definition of the TodoStore abstract class.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
onChanged: (tappedValue) {
        store.filter=tappedValue!; 
      },
\end{minted}
\mbox{}
\end{code}

Personally , I dislike this feature mobx offers in the Flutter framework. I investigated a bit in the usage of MobX with React and JS finding that in that case it behaves as expected raising a warning in case field are directly changed. (violating the strict mode) I find the way of changing the filter value proposed in the Source Code RIFERIMENTO a lot more elegant with respect to the one proposed in the Source Code RIFERIMENTO. Explicitly using predefined actions brings way more meaning for the reader and prevents programmers to accidentally mutate the state in the implementation process. At the end , both approaches pass though actions to change the state and this respect the MobX approach. Actions are indeed really important to the correct functioning of the application because using them the mobx package can generate atomic state transitions. Suppose a simple action, like the one we just used , produces reactions of different types and those reactions affects different parts of the state and the UI. Suppose now that the strict mode is disabled and set to never. In that case can happen that the various reactions are completed/fired in different interval of time because their carried computation is heavier of lighter depending with respect of the other. Consequently the entire state of the application is not well synchronized and the UI could reflect this inconsistency bringing to some bad situations. Mobx package instead ensure that actions and consequent reactions are performed atomically without leaking any intermediate values as long as actions are used.
\paragraph{The Stats component - }
\label{subpar:todo_app_bloc_core_state} this component is really simple. It just needs to access the TodoStore to get the stats value. The procedure shown in the Source Code RIFERIMENTo is used as usual to get an instance of the TodoStore and consequently of the stats value. The entire widget is then wrapped into an Observer widget .
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final store = Provider.of<TodoStore>(context);
return Observer(
  builder: (context) {
           return Center(child: Text(store.stats));
  },
);
\end{minted}
\mbox{}
\end{code}

\paragraph{The TodoView component and the TodoItem component - }
\label{subpar:todo_app_bloc_core_state} These two components represent the core of the UI development process and no optimizations are considered for the moment. The TodoView widget needs to access the state and rerender once a change occurs in the filteredList of todos. In this scenario the mobx pattern really shines. It is sufficient to wrap the entire widget inside a Observer widget and access the filtered list of todo contained in the TodoStore to allow the mobx package to automatically detect a change in the filtered list. Once the list of todos or the filter is updated the filteredList is automatically computed. As usual the TodoItem just acts as a visualizer for the corresponding todo and so takes as argument the todo instate to be visualized.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final store = Provider.of<TodoStore>(context);
return Observer(
  builder: (_) {
    print("building TodoView");

    return ListView.builder(
      itemCount: store.filteredTodos.length,
      itemBuilder: (context, index) {
        return TodoItem(
          todo: store.filteredTodos.elementAt(index),
        );
      },
    );
  },
);
\end{minted}
\mbox{}
\end{code}

The TodoItem widget implementation is basically the same presented HERE RIFERIMENTo except for the onChanged field of the TextButton widget that needs to be filled up. Inside the provided function the store is retrieved using the Provider widget and used to fire the setCompleted action using the todo’s id and the new value for the completed field. Notice ,to be precise, that also in this case the completed field could be changed directly without any error.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
onChanged: (value) {
  final store = Provider.of<TodoStore>(context);
  store.setCompleted(todo.id, value!);
  // todo.completed = value!;
}),
\end{minted}
\mbox{}
\end{code}

The base functionalities are now working fine.
\subsubsection{Features addition} \mbox{}\\ \label{par:todo_app_inherited_widget_introduction}In order to add and update todos its necessary to define two new actions. Also in this case the creation of these two new actions could be avoided because setter and getter methods already exists for the list of todos. However , actions carry a lot more meaning and enable to avoid code duplication. Two new methods are added to the TodoStore class and annoted with the @action syntax. The functioning is the usual one, in the addTodo method a new todo instance is created with an unique id and added to the list of todos. In the updateTodo method the id argument is used to search for the corresponding todo and the name and desc argument are used to update it. Both methods need to substitute the todo’s list with a new instance to allow the mobx package to recognize the change. Subsequently the code is generated again using the line of code presented HERE RIFERIMENTO.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@action
void updateTodo(int id, String name, String desc) {
  assert(todoExists(id) != null, 'No todo with id : \$id');
  Todo todo=todos.where((element) => element.id==id).first;
  todo.name=name;
  todo.description=desc;
}


@action
void addTodo(String name, String desc) {
  Random rand = Random();
  List<int> ids = todos.map((e) => e.id).toList();
  int newId = rand.nextInt(1000) + 2;
  while (ids.contains(newId)) {
    newId = rand.nextInt(1000) + 2;
  }
  Todo newTodo = Todo(
      id: newId,
      name: name,
      description: desc + " " + newId.toString(),
      completed: false);

  todos.add(newTodo);
  todos = todos.toList();
}
\end{minted}
\mbox{}
\end{code}

Accessing these new actions in the UpdateTodoPage and in the AddTodoPage is simple by the fact that the Provider widget has been situated as parent of the MaterialApp widget ( from where different roots generate). In the onPressed field of the TextButton situated in the AddTodoPage the store is retrieved using the Provider’s of method and used to fire a action of type addTodo. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
onPressed: () {
  final store =
      Provider.of<TodoStore>(context, listen: false);
  store.addTodo(
      textControllerName.text, textControllerDesc.text);
  Navigator.pop(context);
}
\end{minted}
\mbox{}
\end{code}

The same is done for the onPressed field of the TextButton in the UpdateTodoPage.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
onPressed: () {
  final store =
      Provider.of<TodoStore>(context, listen: false);
  store.updateTodo(widget.todo.id, textControllerName.text,
      textControllerDesc.text);
  Navigator.pop(context);
},
\end{minted}
\mbox{}
\end{code}

\subsubsection{Rendering optimizations} \mbox{}\\ \label{par:todo_app_inherited_widget_introduction}
Mobx package allows to perform the optimizations in an easy and direct way. All the effort is taken by the packages itself and the only thing to be cared about is to fragment the state in the most suited granularity for the purpose. In other words it is sufficient to make the state observable in the right points and wrap the corresponding UI elements into Observer widgets to get the job done. In the implementation provided so far for the list of todos, the only observable part was the list itself. The list is observed by the package and by the Observer widget contained in the TodoView. There is no concept of observability in the single todos yet and , once an instance of todo is change, what is seen by the package is just a completely new list. Consequently , every Observer widget listening for changes in the todo list is rebuilt. The smallest observable element the package sees is the list itself. Said that, the first thing to do in order to optimize the renderings is to increase the granularity of the observed state. Not the list only but also every contained todo needs to be made observable. It is necessary tough to redefine the todo model. This necessity arises with the usage of the mobx package and has not been faced in the other state management solutions used so far. The mobx state management solution introduces a dependency also in the data layer and in the model definition beside the usual dependency introduced in the business logic layer. In some scenarios this could represent an untoward drawback, for example in the porting processes. The Todo model class need to be made abstract an to implement the Store behaviour as we did for the TodoStore. Now it is possible to annotate its internal fields with the @action syntax. All the fields except the id need to be observable. Moreover, the final attribute must be removed to all the observed variables. It is indeed meaningless to observe a variable that cannot be mutated.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
part 'todo.g.dart';


class Todo = _Todo with _\$Todo;

abstract class _Todo with Store{

   final int id;
  @observable
   String name;
  @observable
   String description;
  @observable
   bool completed;
(…)
}
\end{minted}
\mbox{}
\end{code}

Using the line of code presented HERE RIFERIMENTO the todo.g.dart file is generated. The TodoItem widget is “stateless” for the moment. It receives a copy of the corresponding todo instance from the parent. We need to retrieve the instance directly from the store if we want the Observer widget to rebuild correctly and react to changes. Instead of receiving the entire todo from the parent the id field is enough. It is used then in the build method to access the corresponding todo instance in the store using the Provider widget. The remaining TodoItem code remains the same except for the fact that it is wrapped into an Observer widget.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - extension to InheritedWidget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class TodoItem extends StatelessWidget {
  final int id;

  const TodoItem({Key? key, required this.id}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final store = Provider.of<TodoStore>(context, listen: false);
    final todo = store.todos.where((element) => element.id == id).first;
    return Observer(builder: (_) {
      print("building TodoItem \${todo.id}");

      return InkWell(…);
    });
  }
}
\end{minted}
\mbox{}
\end{code}

\subsubsection{Conclusions} \mbox{}\\ \label{par:todo_app_inherited_widget_introduction}
