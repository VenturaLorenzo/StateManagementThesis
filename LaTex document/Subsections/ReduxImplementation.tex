This section implements the Todo application using the Redux package in order to handle the state. 
\subsubsection{Base funtionalities}  \label{par:todo_app_inherited_widget_introduction}
\hfill\\
\paragraph{The AppState - }
\label{subpar:todo_app_bloc_core_state}

Redux solution requires the state to be centrilized in a unique location. A model for this centrilized component must be defined in order to group up all the subparts. Subparts of the state regarding the filter and the tab have been already modelled in the implementation of the shared parts in paragraph  \ref{par:todo_app_models_and_repository} in Source Code \ref{code:2.2} and \ref{code:2.3}. They are used now to compose a new class, called AppState, that groups all the subparts in a unique place throughout the entire application. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - AppState model implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class AppState {

  VisibilityFilter visibilityFilter;
  List<Todo> todos;
  TabState tabState;

  AppState({this.todos=const [],
  this.tabState= TabState.todos,
  this.visibilityFilter= VisibilityFilter.all});
}
\end{minted}
\mbox{}
\end{code}

Notice that the list of filtered todos is not contained in the AppState model. When the Redux solution is used, indeed, the centralized state is kept as simple as possible and the parts of the state that can be computed or derived should be omitted. The filtered list of todo will be computed in the presentation layer when needed. This approach, however, can introduce reduntant computations due to the fact that the filtered list is calculated at every widget's build. This is where Selectors come into play; they propose a mechanism based on the memoization techinque in order to reuse precomputed values. This aspect will be deeper investigated later.
\paragraph{The actions - }
\label{subpar:todo_app_bloc_core_state}In order to mutate the state is necessary to define \textit{actions}. Actions are processed by reducers to produce new states. Actions are just instances of predeclared classes. We start defining the action's classes needed to change the state regarding the list of todos. As usual, the first two features to be implemented are the fetching process and the setting of the \textit{completed} field of a specific todo. Due to the way Redux works, asynchronous actions are handled by Middlewares. Reducers, indeed, are pure functions and are not suited for handling asynchronous code. Two actions are defined just for the fetching process. One is called \textit{LoadTodoAction} and will be intercepted by the middleware which takes care of fetching todos from the database. The second is called \textit{LoadTodoSuccededAction} and carries the list of fetched todos. When the fetching process in the middleware terminates, a new \textit{LoadTodoSuccededAction} is emited and handled by the AppState's reducers.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - actions implementation for the fetching process} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class LoadTodoAction{
  @override
  String toString(){
    return "LoadTodoAction";
  }
}
class LoadTodoSucceededAction{
  List<Todo> todos;
   LoadTodoSucceededAction(this.todos);
   
   @override
  String toString(){
    return "LoadTodoSucceededAction";
  }
}
\end{minted}
\mbox{}
\end{code}

Another action class is created in order to handle the setting o the \textit{completed} field. In this case the action is synchronous and is directly handled by reducers. This new action is called \textit{SetCompletedAction} and contains the id of the todo to be changed and the new value for the \textit{completed} field.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - SetCompletedTodoAction implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class SetCompletedTodoAction {
  final int id;
  final bool completed;

  SetCompletedTodoAction(this.id, this.completed);
  
   @override
  String toString(){
    return "SetCompletedTodoAction";
  }
}
\end{minted}
\mbox{}
\end{code}

Two more actions are needed in order to handle the tab's and the visibility filter's changes. They are called respectively  \textit{SetTabAction} and \textit{SetVisibilityFilterAction}. They contains the new \textit{tab} value and the new \textit{filter} value to be set.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - SetTabAction and SetVisibilityFilterAction implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class SetTabAction{
  final TabState newtab;

  SetTabAction(this.newtab);
  
   @override
  String toString(){
    return "SetTabAction";
  }
}

class SetVisibilityFilterAction{
  VisibilityFilter filter;

  SetVisibilityFilterAction(this.filter);
  
    @override
  String toString(){
    return "SetVisibilityFilterAction";
  }
}
\end{minted}
\mbox{}
\end{code}

\paragraph{Reducers - }
\label{subpar:todo_app_bloc_core_state}
Is the turn now for reducers's definition. They link actions with new states. Even if the usage of the Redux state management solution requires the centralization of the state in a unique component, the stateâ€™s logic can be in any case split up in subparts. It is like a tree with a single root where the root is represented by the AppState's reducer.  It can split up in many sub-reducers and every one of them can further split up into other sub-reducers. Therefore, the state is stored in single place, but its pieces can still be segmented and managed separately and independently. During the reasoning process it is easier to break the whole state into smaller pieces step by step using a top-down approach. However, in the implementation process, a bottom-up approach is usually taken. This is due to the fact that, during the implementation process, smaller bricks are required to build bigger components. In this presentation, for example, is not possible to define directly the AppState's reducer even if, logically, it should be the first reducer to be implemented. The AppState's reducer is composed by multiple sub reducers, in our case three. There is a reducer for the list of todos, a reducers for the filter and a reducer for the tab. 
\paragraph{The todoReducer - }
\label{subpar:todo_app_bloc_core_state}
The reducer for the list of todos needs to handle two actions, the \textit{LoadTodoSuccedeedAction} and the \textit{SetCompletedTodoAction}. The \textit{todoReducer} is a combination of two subreducers both handling a specific action. As we already said, reducers are pure functions. They take the previous state and an action and return the next state. The reducer for the \textit{LoadTodoSuccedeedAction} is called \textit{setLoadedTodo} and just returns the list contained in the received action.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - LoadTodoSuccedeedAction reducer implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
List<Todo> _setLoadedTodo(List<Todo> todos,
 LoadTodoSucceededAction action) {
  return action.todos;
}
\end{minted}
\end{code}
The reducer for the \textit{SetCompletedTodoAction} is called \textit{setCompletedTodo} and takes care of searching in the current list of todos the todo matching the id contained in the action. Once found, it is updated and a new instance of the whole list is created and returned. The necessity to create another instance for the list comes from the fact that, in order to recognize a state change, Redux needs to identify differences between the current state and the previous one. If we just update the list it would result to be equal to the previous one and the transition would not be recognised.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - SetCompletedTodoAction reducer} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
List<Todo> _setCompletedTodo(List<Todo> todos,
 SetCompletedTodoAction action) {
  List<Todo> newList= todos.map((todo) => todo.id == action.id
      ? Todo(
          id: action.id,
          name: todo.name,
          description: todo.description,
          completed: action.completed)
      : todo).toList();

  return List.from(newList);
}
\end{minted}
\mbox{}
\end{code}

Now that all reducers related to the list of todos have been implemented we use some tools, the Redux package provides, in order to combine them in a single one binding the received actions to the correct sub-reducer. These tools are the \textit{combineReducers} function and the \textit{TypedReducer} class. The \textit{TypedReducer} class is, indeed, a typed class that helps avoiding nested if-else structures which can generate lot of boilerplate and code unreadability. It binds a specific action to a reducer. \textit{combineReducers} , instead, is a function that creates a new reducer composing sub-reducers provided in the form of \textit{TypedReducers}. The two previously defined reducers are now merged into a single one called \textit{todosReducer}.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - todoReducer implementation using \textit{combineReducers} function} \mbox{}
		\label{code:2.56}
\begin{minted}[bgcolor=bluepoli!10]{dart}
final todoReducer = combineReducers<List<Todo>>([
  TypedReducer<List<Todo>, LoadTodoSucceededAction>(_setLoadedTodo),
  TypedReducer<List<Todo>, SetCompletedTodoAction>(_setCompletedTodo),
]);
\end{minted}
\mbox{}
\end{code}

The alternative would have been to write the \textit{todosReducer} as presented in Source Code \ref{code:2.57}. The output is the same but the code is clearly less readable.
\begin{code}
\mbox{}
\captionof{listing}{Todo app - Redux - todoReducer implementation using the traditional way} \mbox{}
		\label{code:2.57}
\begin{minted}[bgcolor=bluepoli!10]{dart}
final todosReducer = (List<Todo> todos, action) {
  if (action is LoadTodoSucceededAction) {
    return _setLoadedTodo(todos,action);
  } else if (action is SetCompletedTodoAction) {
    return _setCompletedTodo(todos, action);
  } else {
    return state;
  }
};
\end{minted}
\mbox{}
\end{code}

\paragraph{The tab's reducer and the visibility filter's reducer - }
\label{subpar:todo_app_bloc_core_state}
The process is the same as before. Two reducers, called \textit{setTabState} and \textit{setVisibilityFilter}, are created in order to handle the actions of type \textit{SetTabAction} and \textit{SetVisibilityFilterAction} respectively. In both cases the value contained in the action is used to produce a new state. Both of them are used to create  two other reducers called \textit{tabReducer} and \textit{visibilityFilterReducer} using the \textit{combineReducers} function introduced earlier. In this case the usage of the \textit{combineReducers} function wasnâ€™t really necessary by the fact that it combines only one reducer. However, in case new actions are introduced it gets handy.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - tabReducer and visibilityFilterReducer implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
//reducer for the tab
TabState _setTabState(TabState state, SetTabAction action){
   return action.newtab;
}
//combineReducers for the tab
final tabReducer= combineReducers<TabState>([
  TypedReducer<TabState, SetTabAction>(_setTabState),

]);
//reducer for the filter
VisibilityFilter _setVisibilityFilter(
    VisibilityFilter oldState, SetVisibilityFilterAction action) {
  return action.filter;
}
//combineReducers for the filter
final visibilityFilterReducer = combineReducers<VisibilityFilter>([
  TypedReducer<VisibilityFilter, SetVisibilityFilterAction>(
      _setVisibilityFilter)
]);
\end{minted}
\mbox{}
\end{code}

\paragraph{The AppState reducer - }
\label{subpar:todo_app_bloc_core_state}
All the basic bricks have been implemented and can be used now to create the biggest reducer; the AppState's reducer. It is a function that takes the current \textit{AppState} and an action. It then creates a new AppState instance using the sub-reducers it is composed of. Every sub-reducer processes the received action in order to investigate the necessity of perfom a transition in the part of the state it handles. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - appStateReducer implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
AppState appStateReducer(AppState appState, action) {
  return AppState(
      todos: todoReducer(appState.todos, action),
      tabState: tabReducer(appState.tabState, action),
      visibilityFilter: visibilityFilterReducer(appState.visibilityFilter,
      action));
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The Middleware - }
\label{subpar:todo_app_bloc_core_state}
All the necessary elements in order to start accessing the state in the presentation layer are settled up but the way in which todos are fetched from the database is not clear yet. Two actions were set up for this purpose but only one has been handled by a reducer. The process of fetching todos from the database is not immediate. It is asynchronous with respect to the application workflow. Reducers are not suited for handling asynchronous code, they need to be pure and as simple as possible. There are many ways, in practice, to deal with asynchronous code using Redux but, the most correct one (and also the one proposed in the documentation) is to use Middlewares. Middlewares has been introduce HERE RIEFERIMENTO. They act as a sort of proxy between actions and reducers. One or more middlewares can be set to be executed on actions' emission. They are used to handle asynchronous code but also side effects generated by actions. In our case, an action of type \textit{LoadTodoAction} has been defined but is not handled by any reducer yet and it is ignored once received. However, it will pass through one or more middlewares before reaching the reducers. It is necessary  to set up a middleware that intercepts it and starts the fetching process. A middleware is just a function that takes three parameters: the \textit{store}, an \textit{action} and the \textit{next} dispatcher. It processes the action, probably accessing the store, and then passes the action to the next middleware. A new middleware function is defined and called \textit{loadTodoMiddleware}. It  checks if the dispatched action if of type \textit{LoadTodoAction} and, in case it is, starts to load the todos from the database. Once the fetching process is completed it dispatches an action of type \textit{LoadTodoSuccededAction} that contains the list of fetched todos. We previously set up a specific reducer in order to handle this type of action in the AppState reducer.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - loadTodosMiddleware middleware implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
void loadTodosMiddleware(Store<AppState> store, action,
 NextDispatcher next) {

  if (action is LoadTodoAction) {
    TodoRepository.loadTodos().then((todos)
     {store.dispatch(LoadTodoSucceededAction(todos));} );
  }
  next(action);
}
\end{minted}
\mbox{}
\end{code}

All the ingredients are now available to start composing our UI.

\paragraph{Making the state accessible - }
\label{subpar:todo_app_bloc_core_state}
Redux solution uses Provider widgets to make the state accessible down the widgets tree. The state is unique and, therefore, should  be placed in the root of the widgets tree, otherwise, some parts of the tree would not be covered by its accessibility. To do so, a StoreProvider widget is positioned at the root of app, right below the MyApp widget. An object of type Store must be provided to the StoreProvider widget, in the \textit{store }field. The typed class Store is provided by the Redux package. In our case, the global state is modelled by the AppState class. The Store class constructor takes three parameters. The reducer for the AppState, an AppState instance that identifies the initial state and a list of middlewares. In our case a single middleware is used. In order to fetch todos at the application start we will use the \textit{init} method of stateful widgets.  The HomePage is already stateful and its \textit{init} method is used in order to dispatch the first action : the \textit{LoadTodosAction}. For simplicity the function to be executed in the \textit{init} method is passed from the MyApp widget, where the store is already available, to the HomePage using a newly created parameter.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo a
pp - Redux - makes the Store accessible using a StoreProvider widget} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
void main() {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(MyApp(
      store: Store<AppState>(appStateReducer,//pass the AppState's reducer
          initialState: AppState(), middleware: [loadTodosMiddleware])));
}

class MyApp extends StatelessWidget {
  final Store<AppState> store; //new parameter

  const MyApp({Key? key, required this.store}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    print("Building Material App");
    return StoreProvider(// use a StoreProvider widget
      store: store, //use the new parameter here
      child: MaterialApp(initialRoute: "/",
        routes: {
          //pass the todos's fetching action to the HomePage
          "/": (context) => HomePage(onInit: (){
            store.dispatch(LoadTodoAction());
            },),
            (...) 
         },
      ),
    );
  }
}
\end{minted}
\mbox{}
\end{code}

Inside the HomePage, the \textit{initState} method is set up in order to dispatch a \textit{LoadTodoAction} using the function passed as parameter by the MaterialApp widget. In order to access the store, a StoreConnector widget is used. A StoreConnector widget takes two functions in its \textit{converter }and \textit{builder }fields. The \textit{converter} function takes the state and creates a viewmodel containing the minimal information necessary to build the widget. The \textit{builder} function actually uses the viewmodel in order to create the widget. The viewmodel is really important because idenfies the prospective from which, the widget, is looking at the centralized state. If the viewmodel changes the widget is rebuilt. Not always a state change produces a viewmodel change. The StoreConnector widget is a typed widget and takes two types in its definition: the store's type (the AppState) and the viewmodel's type (in this case just a TabState object). The HomePage only needs the part of the state related to the tab and, for this reason, it is not necessary to create an ad hoc viewmodel. The model of the TabState defined in Source Code \ref{code:2.2} is enough to contain the necessary part of the state for the HomePage creation. In the \textit{converter }field a function is provided which manipulates the state returning the current TabState value. The \textit{builder} field is populated with a function that returns the usual Scaffold widget. Inside this function, the current \textit{context} and the object returned from the \textit{converter} function can be used. This last one is used to populate the Scaffold widget as usual.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - HomePage implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}

class HomePage extends StatefulWidget {
  final void Function() onInit; //new parameter

  const HomePage({Key? key, required this.onInit}) : super(key: key);

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  @override
  void initState() {
   //using the new function parameter to start the fetching process
    widget.onInit();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    print("Building HomePage");
  //use a StoreConnector widget to access the state
    return StoreConnector<AppState, TabState>(
      //scan the store to retrive the current tab value
      converter: (store) => store.state.tabState,
      builder: (context, currTab) {
        return Scaffold(
            appBar: AppBar(
              title: const Text("Todo App"),
              actions:  [
                currTab == TabState.todos //use it here
                    ? const VisibilityFilterSelector()
                    : Container()
              ],
            ),//use it here
            body: currTab == TabState.todos ? const
             TodoView() : const Stats(),
            bottomNavigationBar: const TabSelector(),
            floatingActionButton: currTab == TabState.todos //use it here
                ? FloatingActionButton(...)
                : Container());
      },
    );
  }
}
\end{minted}
\mbox{}
\end{code}

We can now start implementing the component widgets but, first, a short digression about Selectors is taken.
\paragraph{Selectors - }
\label{subpar:todo_app_bloc_core_state}
They are introduced hereRIFERIMENTO . Selectors are used to compute those parts of the state that entirely depends on other parts. In our case, for example, the filtered list entirely depends on the list of todos and the visibility filter. It is not included in the AppState with the idea of computing it in the presentation layer. This decision also comes from the fact that, if situated in the centralized state, would be hard to syncornize it with the changes in the todos list and in the visibility filter. The easiest way to deal with the filtered list is to compute it in the presentation layer before building the TodoView widget. However, this way of doing can become soon quite heavy by the fact that the computation of the filtered list is perfomed every time the widget is rebuilt. In this scenario Selectors come into play to memoize the previously computed values and to reuse them once accessed. Selectors are just functions that take as input the state an return an element composed using it. All the memorization part is perfomed by a third party package called \textit{Reselect}. In order to use this package it must be included in the pubspec.yaml file under the \textit{dependencies} field. It provides some functions called \textit{createSelector} that take care of memoizing precomputed values and understanding when is necessary recompute them. Selectors can be simple or composed. For example, two simple selectors can be implemented in our case. One takes the state and returns the visibility filter and the other takes the state and returns the list of todos.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - first level Selectors implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
final todosSelector = (AppState state) => state.todos;

final filterSelector = (AppState state) => state.visibilityFilter;
\end{minted}
\mbox{}
\end{code}

Selectors can be composed with other selectors to create articulated objects. Selectors are composed using the \textit{createSelector} function followed by a number. For example, a selector computing the list of completed todos can be built using the \textit{todosSelector }and the \textit{createSelector1} function. The same con be done to compute the list of pending todos. Another Selector is created to finally compute the filtered list. It uses the four other selectors we just implemented and the \textit{createSelector4 }function. Besides of making the code more readable , selectors, allow to optimize the application's performances.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - composed  Selectors implementation} \mbox{}
		\label{code:2.64}
\begin{minted}[bgcolor=bluepoli!10]{dart}
//computer the list of completed todos
final completedTodosSelector = createSelector1(
    todosSelector,
    (List<Todo> todos) =>
        todos.where((todo) => todo.completed == true).toList());

//compute the list of pending todos
final pendingTodosSelector = createSelector1(
    todosSelector,
    (List<Todo> todos) =>
        todos.where((todo) => todo.completed == false).toList());

//compute the filtered list
final filteredTodosSelector = createSelector4(
    todosSelector, filterSelector,
     completedTodosSelector, pendingTodosSelector,
    (List<Todo> todos, VisibilityFilter filter, List<Todo> completed,
        List<Todo> pending) {
  switch (filter) {
    case VisibilityFilter.completed:
      return completed;
    case VisibilityFilter.notCompleted:
      return pending;
    case VisibilityFilter.all:
      return todos;
  }
});
\end{minted}
\mbox{}
\end{code}

\paragraph{The TodoView component - }
\label{subpar:todo_app_bloc_core_state}
After this short digression about selectors, we are ready to set up the TodoView component. Its internal ListView widget is wrapped into a StoreConnector widget typed with the AppState type and the List<Todo> type. The TodoView component just needs to access the part of the state concerning the filtered list of todos that is representable with an object of type List<Todo>. The list of filtered todos is not directly available in the AppState but selectors can be used to compute it. In the \textit{converter }field of the StoreConnector widget, a function is provided which takes the store and returns the filtered list using the \textit{filteredTodosSelector} defined Source Code \ref{code:2.64}. The \textit{converter} function's output is available inside the \textit{builder} field's function and is used to populate the ListView widget as usual. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - TodoView component implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class TodoView extends StatelessWidget {
  const TodoView({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    //use the StoreConnector widget to access the state
    return StoreConnector<AppState, List<Todo> >(
        builder: (context, todos) {
          print("Building TodoView");
          return ListView.builder(
            itemCount: todos.length, //use it here
            itemBuilder: (context, index) {
              return TodoItem(
                todo: todos.elementAt(index), //use it here
              );
            },
          );
        },
        converter: (store) {
          //use the selector
          return filteredTodosSelector(store.state);
        });
  }
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The TodoItem component - }
\label{subpar:todo_app_bloc_core_state}

The TodoItem component does not require any modification with respect to the implementation proposed in Source Code \ref{code:2.8}. It just receives a todo from the parent widget and exposes it to the user. The only missing part is the \textit{onChanged} field of the Checkbox widget which is still empty. Inside the \textit{onChanged} field, a function must be provided which updates the \textit{completed} field of the visualized todo. The store is accessed using the \textit{of} method of the StoreProvider widget (the \textit{of} method gets the nearest instance of provided type, in our case AppState). The store is then used to dispatch an action of type \textit{SetCompletedTodoAction} created using the id, of the visualized todo, and the \textit{completed} Boolean value provided by the \textit{onChanged} function.

\begin{code}
\mbox{}
\captionof{listing}{Todo app - Redux - TodoItem component's \textit{onChanged }field implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
Checkbox(
    value: todo.completed,
    onChanged: (completed) {
      StoreProvider.of<AppState>(context).dispatch(
          SetCompletedTodoAction(todo.id, completed!));
    }),
\end{minted}
\mbox{}
\end{code}

\paragraph{The VisibilityFilterSelector component - }
\label{subpar:todo_app_bloc_core_state}
The VisibilityFilterSelector component only accesses the part of the state concerning the filter. The entire DropdownButton widget is wrapped into a StoreConnector widget. The StoreConnectorâ€™s \textit{converter} field  is filled with a function taking the store and returning the current filter value. To do so, it uses the \textit{filterSelector} selector implemented earlier in Source Code \ref{code:2.63}. The output of the \textit{converter} function is accessed in the \textit{builder} field function and used to populate the DropdownButton widget. The function used in the \textit{onChanged} field of the DropdownMenuItem widgets gets an instance of the store using the StoreProvider widgetâ€™s \textit{of} method and dispatches an action of type \textit{SetVisibilityFilterAction} using the DropdownMenuItem 's filter value.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - VisibilityFilterSelector component implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
@override
Widget build(BuildContext context) {
  //using a StoreConnector widget to access the state
  return StoreConnector<AppState, VisibilityFilter>(
    //scan the store to retrive the filter value
    converter: (store) => filterSelector(store.state),
    builder: (context, activeFilter) {
      print("Building Visibility filter");

      return DropdownButton<VisibilityFilter>(
        value: activeFilter, //use it here
        items: (...),
        onChanged: (filter) {
          //dispatch an action of type SetVisibilityFilterAction
          StoreProvider.of<AppState>(context)
              .dispatch(SetVisibilityFilterAction(filter!));
        },
      );
    },
  );
\end{minted}
\mbox{}
\end{code}

\paragraph{The TabSelector component - }
\label{subpar:todo_app_bloc_core_state}
Also in this case, the TabSelector component requires to read and also write the AppState. A StoreConnector widget is used to wrap the BottomNavigationBar widget and to connect it to the state. The viewmodel to be returned by the \textit{converter} function is just an object of type TabState. An arrow function returning the current AppStateâ€™s tab value is provided to the \textit{converter} field. The function's output is then used in the \textit{builder} field's function to populate the BottomNavigationBar widget. The \textit{onTap} field of the BottomNavigatioBar widget is filled with a function that dispatches an action of type \textit{SetTabAction} when fired.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - TabSelector component implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class TabSelector extends StatelessWidget {
  const TabSelector({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    //use a StoreConnector widget to access the state
    return StoreConnector<AppState, TabState>(
      //scan the store to retrive the tab value
      converter:(store)=>store.state.tabState,
      builder: (context, currTab) {
        print("Building Tab Selector");

        return BottomNavigationBar(
          //use it here
          currentIndex: TabState.values.indexOf(currTab),
          onTap: // dispatch an action of type SetTabAction
           (index)=>StoreProvider.of<AppState>(context)
           .dispatch(SetTabAction(TabState.values.elementAt(index))),
          items: (...)
        );
      },
    );
  }
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The Stats component - }
\label{subpar:todo_app_bloc_core_state}
The stats component only requires to read the state. The Center widget is wrapped into a StoreConnector widget. In the \textit{converter} field's function the \textit{completedTodoSelector} defined in Source Code \ref{code:2.64} selector is used to access the list of completed todos. In this case the viewmodel to be outputted is just an int value representing the number of completed todos.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - Stats component implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class Stats extends StatelessWidget {
  const Stats({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    //use the StoreConnector widget to access the state
    return StoreConnector<AppState, int>(
      builder: (context, completed) {
        print("Building Stats");
        //use it here
        return Center(child: Text(completed.toString()));
      },
      converter: (store) {
        // use the selector
        return completedTodosSelector(store.state).length;
      },
    );
  }
}
\end{minted}
\mbox{}
\end{code}

At this point all the base functionalities have been implemented and are working fine.
 

\subsubsection{Features addition}  \label{par:todo_app_inherited_widget_introduction}

The first thing to do is to make the state provide a way of adding and updating todos. For this purpose two new actions are created with the name \textit{AddTodoAction} and \textit{UpdateTodoAction} respectively. In the \textit{AddTodoAction}, are contained the name and the description for the todo to be create. In the \textit{UpdateTodoAction}, besides the new name and description, also the id of the todo to be modified is contained.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - AddTodoAction and UpdateTodoAction implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class AddTodoAction {
  final String name;
  final String desc;

  AddTodoAction(this.name, this.desc);
}

class UpdateTodoAction{
  final String name;
  final String desc;
  final int id;

  UpdateTodoAction(this.name,this.desc,this.id);
}
\end{minted}
\mbox{}
\end{code}

In order to handle these new actions two new reducers are  created. They are called respectively \textit{addTodo} and \textit{updateTodo}. The \textit{addTodo} reducer  creates a new todo using the information contained in the \textit{AddTodoAction}  instace and a newly generated unique id. Then, it creates a new list instace and populates it with the elements of the old list plus the new todo.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - addTodo reducer implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
List<Todo> _addTodo(List<Todo> todos, AddTodoAction action) {
  //generate new unique id
  int newId = generateId(todos);
  //create a new todo instance
  Todo newTodo = Todo(
      id: newId,
      name: action.name,
      description: action.desc + " " + newId.toString(),
      completed: false);

  return List.from(todos)..add(newTodo);
}
\end{minted}
\mbox{}
\end{code}

The \textit{updateTodo} reducer modifies the todo with the id matching the one contained in the action. Then, it generates a new list and fills it with the element contained in the current one.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - updateTodo reducer implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
List<Todo> _updateTodo(List<Todo> todos, UpdateTodoAction action){

  List<Todo> newList= todos.map((todo) => todo.id == action.id
      ? Todo(
      id: action.id,
      name: action.name,
      description: action.desc,
      completed: todo.completed)
      : todo).toList();

  return List.from(newList);
}
\end{minted}
\mbox{}
\end{code}

These new reducers are then combined with the already existing ones in the \textit{combineReducers} function and linked with the corresponding action using the typed class \textit{TypedReducer}.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - adding addTodo reducer and updateTodo reducer to the todoReducer} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
final todoReducer = combineReducers<List<Todo>>([
  TypedReducer<List<Todo>, AddTodoAction>(_addTodo), //new reducer
  TypedReducer<List<Todo>, LoadTodoSucceededAction>(_setLoadedTodo),
  TypedReducer<List<Todo>, SetCompletedTodoAction>(_setCompletedTodo),
  TypedReducer<List<Todo>, UpdateTodoAction>(_updateTodo), //new reducer
]);
\end{minted}
\mbox{}
\end{code}

The AppState can now handle actions of type \textit{AddTodoAction} and \textit{UpdateTodoAction}. These new functionalities can now be used in the AddTodoPage and in the UpdateTodoPage. The StoreProvider widget has been positioned in the root of the application to be available in all the subtrees. Is sufficient, tough, to access the store in the AddTodoPage and dispatch an action of type \textit{AddTodoAction}, when the TextButton widget is tapped.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - AddTodoPage \textit{onPressed }field implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
TextButton(
    onPressed: () {
      //create a new action
      final AddTodoAction action= AddTodoAction(textControllerName.text,
       textControllerDesc.text);
	  //dispatch it      
      StoreProvider.of<AppState>(context).dispatch(action);
      Navigator.pop(context);
    },
\end{minted}
\mbox{}
\end{code}

The same is done in the UpdateTodoPage. Once the TextButton widget is tapped an action of type \textit{UpdateTodoAction} is dispatched.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - UpdateTodoPage \textit{onPressed }field implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
TextButton(
    onPressed: () {
      //create an action
      final UpdateTodoAction action=
       UpdateTodoAction(textControllerName.text,textControllerDesc.text,widget.todo.id);
	  //dispatch it      
      StoreProvider.of<AppState>(context).dispatch(action);
      Navigator.pop(context);
    },
    child: const Text("Confirm"))
\end{minted}
\mbox{}
\end{code}

All the features have been successfully added.
\subsubsection{Rendering optimization}  \label{par:todo_app_inherited_widget_introduction}

In order to perform the rendering optimizations we will leverage on the fact that, the StoreConnector widget, only rebuilds when the viewmodel, it relies on, changes. Or better, this happens when a specific field of the StoreConnector widget, called \textit{distinct}, is set to true. This feature, the Redux package provides, makes the optimization process really easy. We just need to define the correct viewmodel and provide it with the correct equality operator. Some changes must be done in the TodoView widget and in the TodoItem widget. Firstly, the TodoItem widget needs to interact with the state in order to understand when a change regarding its todo is performed. For the moment , indeed, the TodoItem widget just receives a todo instance from the parent widget and exposes it to the user. A StoreConnector widget is used to read the state in the TodoItem widget. The complete instance of the todo to be visualized is not necessary anymore but the id only is enough. Using the id , the corresponding todo is searched in the store by the \textit{converter} fieldâ€™s function and passed to the \textit{builder} field. The widget returned by the \textit{builder} function remains the same with the only exception that it uses the todo instance got from the store instead of the one passed by the parent widget. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - accessing the state into TodoItem component} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class TodoItem extends StatelessWidget {
  final int id; //todo variable substituted with a int one

  const TodoItem({Key? key, required this.id})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    //use a StoreConnector widget to access the state
    return StoreConnector<AppState, Todo>(
      //set the distinct value to true enabling 
      //comparison between viewmodels
      distinct: true, 
        converter: (store) =>
          //retrive the corresponding todo scanning the store
            store.state.todos.firstWhere((element) => element.id == id),
        builder: (context, todo) {
          print("building: Todo Item \$id ");
          //the remaining part remains the same
          return InkWell(. . .);
        });
  }
}
\end{minted}
\mbox{}
\end{code}

Now that the TodoItem widget listens for its own todo changes, the optimization process concerning the TodoItem widget is automatically performed. We said, indeed, that the StoreConnector widget is rebuilt every time its viewmodel changes and we set the viewmodel as the corresponding todo instance in the AppStore. Once a state change occurs, the StoreConnector widget compares the current todo with the new one and, in case they differ, it rebuilds. To notice that this mechanism works because we redefined the equality operator between objects of type Todo in Source Code \ref{code:2.4}. An object of type Todo is equal to another one if all their internal values match. This equality differs from the traditional one by the fact that does not check for the entityâ€™s equality. Indeed, if it would, the two todos would appear to be different everytime even if their interna values match. This because, once a new state is emitted, the list of todos is recreated from scratch and its internal todos are replaced with new instances. In the dart language two different objects end to be different also if their internal values are exactly the same. This way of handling object already showed up numerous times in this overview and will show up even more in the next implementations. Going back to the to the TodoItem component , it already uses the correct equality operator to compare different viewmodels and so is capable to understand when to rebuild autonomously. The same process must be done in the TodoView widget. It already uses a StoreConnector widget to derive the list of filtered todos from the store. However, as we just said, two different plain lists appear to be always different by default also if their internal aspects matches, leading to unconditioned rebuilds. Moreover, it is not possible to redefine the equality operator for lists and, also if it would, it would not be a good idea. A simple way to handle this scenario is to create an ad hoc viewmodel and redefine its equality operator in order to match our own rebuilding logic. To do so, a local class is created and called ViewModel. This local class just contains a list of todos.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - TodoView component ad hoc ViewModel implementation} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class _ViewModel {
  final List<Todo> todos;

  _ViewModel({required this.todos});

}
\end{minted}
\mbox{}
\end{code}

 Inside the ViewModel class the equality operator is overridden making two ViewModel instances equal when their length matches and their internal ids match too. In this way the TodoView widget is rebuild only in case the filtered todos list has reported a structural change. (structural and not structural changes are exaplained in paragraph \ref{subsec:renders_optimization}). 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - ViewModel's equality operator override} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
  //redefine the == operator to detect structural changes
  @override
  bool operator ==(Object other) {
    return ((other is _ViewModel) &&
        todos.length == other.todos.length &&
        todos.every(
            (todo) => other.todos.any((element) =>
             todo.id  == element.id)));
  }

  @override
  // TODO: implement hashCode
  int get hashCode => todos.hashCode;
\end{minted}
\mbox{}
\end{code}

After setting the \textit{distinct} field to true and modifying the \textit{converter} function to return a ViewModel instead of a plain List the optimizations are basically done.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - TodoView component renders optimization} \mbox{}
		\label{code:2.14}
\begin{minted}[bgcolor=bluepoli!10]{dart}
class TodoView extends StatelessWidget {
  const TodoView({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return StoreConnector<AppState, _ViewModel>(
        distinct: true, //set the distinc field to true
        builder: (context, vm) {
          print("Building TodoView");
          return ListView.builder(
            itemCount: vm.todos.length, //use the viewmodel
            itemBuilder: (context, index) {
              return TodoItem(
                id: vm.todos.elementAt(index).id, //use the viewmodel
              );
            },
          );
        },
        converter: (store) { //return a ViewModel instead of a plain list
          return _ViewModel(todos: filteredTodosSelector(store.state));
        });
  }
}
\end{minted}
\mbox{}
\end{code}

To put the  the icing on the cake we set the \textit{distinct} field to true also in the VisibilityFilterSelector component and in the TabSelector component. In this way they are rebuilt only in case their prospective of the state changes and not at every state transition.

\subsubsection{Conclusions} 
\label{subpar:render_optimizations_redux}
Table \ref{table:recap_redux} reports some measurements taken from the InheritedWidget's implementation process. The \textit{lines of code} column represents the lines of code added or updated with respect to the shared project structure proposed in subsection \ref{subsec:todo_app_shared_project_structure}. The \textit{time }column represents the time spent in order to implement the corresponding subprocess. The unit of measure \textbf{h} stands for hours and \textbf{m} stands for minutes. The \textit{lines-time ratio} column represents the average number of lines written in a minute. The \textit{classes} column represents the number of created classes in each subprocess.
\begin{table}[H]
    \caption*{\textbf{Recap}}
    \centering 
    
    \begin{tabular}{| l | c | c | c | c |}
    \hline
    \rowcolor{bluepoli!40} % comment this line to remove the color
    \hline
     & \textbf{lines of code} & \textbf{time} & \textbf{lines/time ratio} & +\textbf{classes} \T\B \\
    \hline
    \textbf{base functionalities} & 156 & 9-11 h & 0.26 l/m & 6 \T\B \\ 
    \textbf{feature addition} & 50 & 15-20 m & 2.94 l/m & 2 \T\B\\ 
    \textbf{rendering optimization} & 28 & 1 h & 0.46 l/m & 1
    \T\B\\
    \hline
    \end{tabular}
    \\[10pt]
    \caption{Redux measurement table}
    \label{table:recap_redux}
\end{table}

Figure \ref{image:redux_lines_piechart} represents a pie chart showing the percentage of lines of code written in each implementation's process, including the one regarding the shared structure. The whole process is quite balanced in term of lines of code.
\begin{figure}[H]

\caption*{\textbf{Lines}}
\centering
\begin{tikzpicture}

\pie[rotate =90]{57.3/Shared structure - 314,
    29.5/Base functionalities - 156,
    9.12/Feature addition - 67,
    5.11/Optimizations - 33
    }
 
\end{tikzpicture}
 \caption{Shows the pie chart regarding the lines of code spent in each subprocess for the Redux implementation}
 \label{image:redux_lines_piechart}

\end{figure}
Figure \ref{image:redux_hours_piechart} represents a pie chart showing the percentage of time spent in each implementation's process. Notice that the learning process and the implementation of the base functionalities took more than the 85\% of the entire time.
\begin{figure}[H]
 \caption*{\textbf{Hours}}
\centering
\begin{tikzpicture}

\pie[rotate = 60]{
    88.2/Base functionalities ,
    3/Feature addition,
    8.8/Optimizations 
    }

\end{tikzpicture}
 \caption{Shows the pie chart regarding the hours spent in each subprocess for the Redux implementation}
 \label{image:redux_hours_piechart}

\end{figure}
Figure \ref{fig:struttura_cartelle_redux} shows the final folders structure for the InheritedWidget implementation. The only  file added to the original folders structure is the todo\_provider.dart file.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{Images/struttura_cartelle_redux.png}
    \caption{Shows the final folders structure for the Redux implementation of the Todos app}
    \label{fig:struttura_cartelle_redux}
\end{figure}

Figure \ref{fig:widget_tree_structure_redux} represents the widget's tree structure for the Redux final application. Notice the StoreProvider widget, situated above the HomePage, providing an instance of the store to the subtree. Also notice all the StoreConnector widgets accessing the state using their corresponding viewmodel.

\begin{figure}[H]
    \centering
    \subfloat[Widgets tree structure \textit{todos }tab\label{fig:todos_tab_UI}]{
        \includegraphics[scale=0.6]{Images/albero_redux_todos.png}
    }
    \quad
    \subfloat[Widgets tree structure \textit{stats }tab\label{fig:todos_tab_tree}]{
        \includegraphics[scale=0.6]{Images/albero_redux_stats.png}
    }
    \caption{Shows the widgets tree structure for Redux implementation of the Todos app}
    \label{fig:widget_tree_structure_inheritedwidget}
\end{figure}


