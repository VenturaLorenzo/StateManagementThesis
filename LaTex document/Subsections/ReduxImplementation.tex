In questa sezione la gestione dello stato verrà gestita tramite Redux.
\subsubsection{Base funtionalities} \mbox{}\\ \label{par:todo_app_inherited_widget_introduction}
\paragraph{The AppState - }
\label{subpar:todo_app_bloc_core_state}
Being the state centralized when the redux solution is used, another model must be defined to connect all the components in a unique class. Subparts of the state have been already modelled in the implementation of the shared parts of the application RIFERIMENTO. They are used now to compose a new class, called AppState, that will group all the subparts in a unique place throughout the entire application. The list of filtered todos will not be part of the AppState. In Redux the centralized state is kept as simple as possible and the parts of the state that can be computed or derived should not take part in it. There are two possibilities basically; compute every time the filtered list on the visualization side or use Selectors. This aspect will be deeper investigated later but for now lets start to define the three main reducers.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - AppState model definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class AppState {

  VisibilityFilter visibilityFilter;
  List<Todo> todos;
  TabState tabState;

  AppState({this.todos=const [],this.tabState= TabState.todos,this.visibilityFilter= VisibilityFilter.all});
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The actions - }
\label{subpar:todo_app_bloc_core_state}
The application’s state is basically composed by model classes. In order to mutate the state is necessary to define actions. Actions will then be processed by reducers to change the state. Actions are simple classes. We start defining the actions needed to change the state regarding the list of todos. The list of todos is represented by a object of type list in the AppState. Actions can generate a state transition or none but cannot generate more than one state emission. For this reason two actions are needed to define the todos fetching. One action to indicate the start of the fetching process and one action to actually insert the fetched todos in the todos list in the AppState. The first action will be called LoadTodoAction. The second one will be called LoadTodoSucceededAction and will contain the list of fetched todos.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - Loading todos actions definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class LoadTodoAction{
  @override
  String toString(){
    return "loadTodoAction";
  }
}
class LoadTodoSucceededAction{
  List<Todo> todos;
   LoadTodoSucceededAction(this.todos);
}
\end{minted}
\mbox{}
\end{code}

Moreover , an action to set the completed field of a specific todo is required to be used in the TodoItem checkbox. This action will be called SetCompletedAction and will contain the id of the todo to be changed and the new value for the completed field.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - InheritedWidget - SetCompletedTodoAction definitio} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class SetCompletedTodoAction {
  final int id;
  final bool completed;

  SetCompletedTodoAction(this.id, this.completed);
}
\end{minted}
\mbox{}
\end{code}

Only two more action are needed to handle the tab and the visibility filter changes. They will be called respectively  SetTabAction and SetVisibilityFilterAction. They brings the new tab and the new filter to be set.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - SetTabAction definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class SetTabAction{
  final TabState newtab;

  SetTabAction(this.newtab);
}

class SetVisibilityFilterAction{
  VisibilityFilter filter;

  SetVisibilityFilterAction(this.filter);
}
\end{minted}
\mbox{}
\end{code}

\paragraph{Reducers - }
\label{subpar:todo_app_bloc_core_state}
Defining the state model and the actions was very simple. Is the turn now for reducers which will link the state with the actions. Although the usage of the Redux state management solution requires to centralize all the state in a unique component doesn’t mean that the state’s logic(?) cannot be split in subparts. It is like a tree with a single root where the root is represented by the app state’s reducer.  It can split up, however, in many sub-reducers and every one of them can split up furthermore into other sub-reducers. So, in the end, the state is segmented and stored in single place, but its pieces can still be managed separately and independently. During the reasoning(?) process the whole state is broken into small pieces step by step using a top-down approach however in the implementation process a bottom-up approach is usually used. This is due to the fact that, during the implementation process , smaller bricks are needed to build bigger components. In this presentation, for example, is not possible to define directly the AppState reducer even if, logically, it should be the first one to be implemented. The AppState reducer will be composed by multiple sub reducers, in our case three. There will be a reducer for the list of todos, a reducers for the filter and a reducer for the tab. 
\paragraph{The todoReducer - }
\label{subpar:todo_app_bloc_core_state}
The required functionalities are the loading of the todos from the db and the setting of the completed field of a specific todo. As said before, reducers are basically functions. They take the previous state and an action and return the next state. Speaking about the list of todos , the state is an object of type List<Todo>. It initially empty and is filled up once an event of type loadTodoSucceededAction is received. The list of fetched todos is found inside the action and used to return the new state for the list of todos. The reducer in this case just takes the list and returns it.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - LoadTodoSuccedeedAction reducer} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
List<Todo> _setLoadedTodo(List<Todo> todos, LoadTodoSucceededAction action) {
  return action.todos;
}
\end{minted}
\mbox{}
\end{code}

Another reducer is needed to handle the action of setting the completed field of a specific todos. In the case the received action will be of type SetCompletedTodoAction. The todo matching the id contained in the action is searched and updated using the list’s map method and then a new instance of the list is created and returned. The necessity to create another instance comes from the fact that the transition would not be recognised in case the state’s list is just updated and not substituted.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - SetCompletedTodoAction reducer} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
List<Todo> _setCompletedTodo(List<Todo> todos, SetCompletedTodoAction action) {
  List<Todo> newList= todos.map((todo) => todo.id == action.id
      ? Todo(
          id: action.id,
          name: todo.name,
          description: todo.description,
          completed: action.completed)
      : todo).toList();

  return List.from(newList);
}
\end{minted}
\mbox{}
\end{code}

Now that the two reducers for the action previously created has been implemented we will usesome tools the redux package provides in order to combine them in a unique reducer that binds the received action to the correct sub-reducer. These tools are the combineReducers function and the TypedReducer class. The TypedReducer class is, indeed, a typed class that helps to avoid nested if-else structure which can generate lot of boilerplate and code unreadability. It binds a specific action to a reducer. combineReducers , instead, is a function that creates a reducer composing sub-reducers provided in the form of TypedReducers. The two previously defined reducers are now merged to an unique one called todosReducer.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - combine reducers using combineReducers function} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final todoReducer = combineReducers<List<Todo>>([
  TypedReducer<List<Todo>, LoadTodoSucceededAction>(_setLoadedTodo),
  TypedReducer<List<Todo>, SetCompletedTodoAction>(_setCompletedTodo),
]);
\end{minted}
\mbox{}
\end{code}

the alternative would have been to write the todosReducer like presented RIERIEMENTO. The output is the same but the code is clearly more readable.
\begin{code}
\mbox{}
\captionof{listing}{Todo app - Redux - combine reducers using the traditional way} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final todosReducer = (List<Todo> todos, action) {
  if (action is LoadTodoSucceededAction) {
    return _setLoadedTodo(todos,action);
  } else if (action is SetCompletedTodoAction) {
    return _setCompletedTodo(todos, action);
  } else {
    return state;
  }
};
\end{minted}
\mbox{}
\end{code}

\paragraph{The tab Reducer and the visibility Filter reducer - }
\label{subpar:todo_app_bloc_core_state}
The process is the same as before. Two reducers ,called setTabState and setVisibilityFilter ,are created to handle respectively actions of type SetTabAction and SetVisibilityFilter action. In both cases the value contained in the action is used to produce a new state. Both of them are used to create other two reducers called tabReducer and visibilityFilterReducer using the combineReducers function introduced earlier. In this case the usage of the combineReducers function wasn’t really necessary by the fact that it combines only one reducer. However in case new actions may be introduced it will get handy.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - reducers definition for the tab and the filter state} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
TabState _setTabState(TabState state, SetTabAction action){
   return action.newtab;
}


VisibilityFilter _setVisibilityFilter(
    VisibilityFilter oldState, SetVisibilityFilterAction action) {
  return action.filter;
}

final tabReducer= combineReducers<TabState>([
  TypedReducer<TabState, SetTabAction>(_setTabState),

]);
final visibilityFilterReducer = combineReducers<VisibilityFilter>([
  TypedReducer<VisibilityFilter, SetVisibilityFilterAction>(
      _setVisibilityFilter)
]);
\end{minted}
\mbox{}
\end{code}

\paragraph{The AppState reducer - }
\label{subpar:todo_app_bloc_core_state}
Finally all the basic bricks have been implemented and can be used now to create the biggest reducer; the AppState reducer. It is of course a function that takes the current AppState and an action. It then compose a new AppState instance using the sub-reducers just created and passing to them the received action. Every sub-reducer processes the action to understand if it needs to perfom a transition in the handled part of the state. And that’s it, a unique component handling all the application’s state has been defined combining more sub parts.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - AppState definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
AppState appStateReducer(AppState appState, action) {
  return AppState(
      todos: todoReducer(appState.todos, action),
      tabState: tabReducer(appState.tabState, action),
      visibilityFilter: visibilityFilterReducer(appState.visibilityFilter,action));
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The Middleware - }
\label{subpar:todo_app_bloc_core_state}
All we need to start accessing the state in the UI is settled up but the way in which the todos are fetched from the database is not really clear yet. Two actions were set up for this purpose but only has been handled by a reducer for the moment. The fact is that the process of fetching todos from the database is not immediate. It is asynchronous with respect to the application workflow. Reducers are not suited for handling asynchronous code , they need to be pure and as simple as possible. There are many ways in practice to deal with asyn code but the most “correct” one is to use middlewares. Middlewares has been introduce HERE RIEFERIMENTO. The act as a sort of proxy from the action dispatch and the reducers. One or more middleware can be provided to be executed on a action call. They are used to handle asynchronous code but also action that generate side effects. In our case we defined an action called LoadTodoAction that do not have any meaning in terms of reducers. Once dispatched it will pass through one or more middleware before reaching the reducers. A middleware is just a function that takes three parameters: the store, an action and the next dispatcher. It processes the action , probably accessing the store, and the pass the action to the next middleware. In our case a new middleware function is defined and called loadTodoMiddleware. It just check is the dispatched action if of type LoadTodoAction and in case it is starts to load the todos from the database. Once the fetching process is completed it dispatches another action of type LoadTodoSuccededAction that , this time will be handled, by the AppState reducer.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - loadTodosMiddleware middleware definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
void loadTodosMiddleware(Store<AppState> store, action, NextDispatcher next) {

  if (action is LoadTodoAction) {
    TodoRepository.loadTodos().then((todos) {store.dispatch(LoadTodoSucceededAction(todos));} );
  }
  next(action);
}
\end{minted}
\mbox{}
\end{code}

All the ingredients are now available to start composing our UI.

\paragraph{Making the state accessible - }
\label{subpar:todo_app_bloc_core_state}
Like almost every solution used in this overview , also redux uses providers to make the state accessible down the widgets tree. The state is unique and tough should obviously be placed in the root of the widgets tree or some part of the tree would not be covered by its accessibility. To do so a StoreProvider is used to wrap the entire app positioned right below the MyApp widget. An object of type Store must be provided to the StoreProvider widget. The typed class Store is provided by the redux package. Store class is a typed class meaning that the type of the global state to be handled must be provided. In our case the global state is of the type AppState defined above. The Store class constructor takes three parameters. The reducer for the AppState , an instance of an object of type AppState that identifies the initial state and a list of middlewares. In our case a single middleware is passed. In order to fetch the todos on the application start we will use the init method of the stateful widgets.  The HomePage widget is already stateful and so its init method is used to dispatch the first action : the LoadTodosAction. For simplicity the function to be executed in the init method is passed from the MyApp widget where the store is already available to the HomePage using a newly created parameter.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo a
pp - Redux - Widgets tree root definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
void main() {


  WidgetsFlutterBinding.ensureInitialized();

  runApp(MyApp(
      store: Store<AppState>(appStateReducer,
          initialState: AppState(), middleware: [loadTodosMiddleware])));


}

class MyApp extends StatelessWidget {
  final Store<AppState> store;

  const MyApp({Key? key, required this.store}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    print("Building Material App");
    return StoreProvider(
      store: store,
      child: MaterialApp(initialRoute: "/",
        routes: {
          "/": (context) => HomePage(onInit: (){
            store.dispatch(LoadTodoAction());
            },),
          "/addTodo":(context) =>const AddTodoPage(),
          "/updateTodo" : (context)=> UpdateTodoPage(todo: (ModalRoute.of(context)?.settings.arguments as Todo))
        },
      ),
    );

  }
}
\end{minted}
\mbox{}
\end{code}

Inside the HomePage widget the initState method is defined and the store is accessed for the first time. To access the store a StoreConnector widget is used. Its task is to access the state and to create a viewmodel containing the information related to the pages usage only. The viewmodel is really important because idenfies the prospective from which the widget is looking at the state. If the viewmodel changes the widget is rebuilt. Not always a state change produces a viewmodel change. The StoreConnector widget takes two types in its definition. The global state’s type,the AppState, and the type of the viewmodel it is going to compose, in our case just a TabState object. The HomePage ,indeed, only need the part of the state related to the tab and so it is not necessary to create an ad hoc view model. The model of the TabState defined hereRIFERIMENTO is enough to contain the interesting part of the state.  Two StoreConnector’s fields must be filled to make it work correctly. The converter field and the builder field. In the first one a function must be provided that manipulate the state to return an object of the type previously specified, in our case a object of type TabState. The builder field is populated with a function that returns a widget. Inside this function the current context and the object returned from the converter function are available. The current tab value is used to populate the Scaffold widget as usual.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - state integration in the HomePage} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@override
void initState() {
  widget.onInit();
  super.initState();
}

@override
Widget build(BuildContext context) {
  print("Building HomePage");

  return StoreConnector<AppState, TabState>(
    converter: (store) => store.state.tabState,
    builder: (context, currTab) {
      return Scaffold(
          appBar: AppBar(
            title: const Text("Todo App"),
            actions: const [VisibilityFilterComponent()],
          ),
          body: currTab == TabState.todos ? const TodoView() : const Stats(),
          bottomNavigationBar: const TabSelector(),
          floatingActionButton: currTab == TabState.todos
              ? FloatingActionButton(
                  child: const Icon(Icons.plus_one),
                  onPressed: () {
                    Navigator.pushNamed(context, "/addTodo");
                  })
              : Container());
    },
  );
}
\end{minted}
\mbox{}
\end{code}

We could now start to implement the component widgets using the AppState but first a short digression about Selectors must be taken.
\paragraph{Selectors - }
\label{subpar:todo_app_bloc_core_state}
They are introduced hereRIFERIMENTO . Selectors are used to compute those parts of the state that entirely depends on other parts. In our case the filtered list is not included in the AppState , also because would be hard to deal with it in the centralized state syncornizing it with the changes in the todos list and the filter. The easiest way to deal with the filtered list is to compute it in the UI layer before buildeing the widget, in our case the TodoView widget. However, this way of doing can become quite heavy soon by the fact that the computation of the filtered list is perfomed every time the widge tis rebuilt and it can be costly sometimes. For this reason Selector are used to memoize the previously computed value and reuse them in case they did not change. Selectors are just functions that take as input the state an return an object composed with it. All the memorization part is perfomed by a third party package called Reselect. In order to use it it must be included in the pubspec.yaml file under the dependencies field. It provides some functions with the name createSelector that take care of memoize the values and understand when to recompute them. Selectors can be simple o composed. For example two simple selectors can be implemented in our case. One that takes the state and return the filter and on that takes the state and return the list of todos. Selectors can be composed with other selector to create articulated objects. Selectors are composed using the createSelector function followed by a number. For example a selector computing the list of completed todos can be built using the todos selctor we just created and the same for computing the list of pending todos. A Selector is created then to compute the filtered list. It will use four other selectors. The list of todos selector, the filter selector, the list of pending todos selector and the list of completed todos selector outputs are composed to compute the filtered list of todos. Besides of making the code more readable , selectors also optimize the application performances.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - Selectors definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final todosSelector = (AppState state) => state.todos;

final filterSelector = (AppState state) => state.visibilityFilter;

final completedTodosSelector = createSelector1(
    todosSelector,
    (List<Todo> todos) =>
        todos.where((todo) => todo.completed == true).toList());

final pendingTodosSelector = createSelector1(
    todosSelector,
    (List<Todo> todos) =>
        todos.where((todo) => todo.completed == false).toList());

final filteredTodosSelector = createSelector4(
    todosSelector, filterSelector, completedTodosSelector, pendingTodosSelector,
    (List<Todo> todos, VisibilityFilter filter, List<Todo> completed,
        List<Todo> pending) {
  switch (filter) {
    case VisibilityFilter.completed:
      return completed;
    case VisibilityFilter.notCompleted:
      return pending;
    case VisibilityFilter.all:
      return todos;
  }
});
\end{minted}
\mbox{}
\end{code}

\paragraph{The TodoView component - }
\label{subpar:todo_app_bloc_core_state}
After this short digression about selectors we are ready now to set up the TodoView component. The ListView widget is wrapped into a StoreConnector widget type with the AppState and a list of todos. Indeed, the TodoView component just needs to access the part of the state concerning the filtered list of todos that is in the end an object of type List<Todo>. However, the list of filtered todos is not directly available in the AppState but the selectors we just defined can to be used to compute the filtered list. In the StoreConnector converter field a function is provided that takes the store and returns the filtered list using the filteredTodosSelector function. The converter function output is then available inside the builder field function and we can use it to populate the ListView widget as usual. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - state integration in the TodoView component} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class TodoView extends StatelessWidget {
  const TodoView({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return StoreConnector<AppState, List<Todo> >(
        distinct: true,
        builder: (context, todos) {
          print("Building TodoView");
          return ListView.builder(
            itemCount: todos.length,
            itemBuilder: (context, index) {
              return TodoItem(
                todo: todos.elementAt(index),
              );
            },
          );
        },
        converter: (store) {
          return filteredTodosSelector(store.state);
        });
  }
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The TodoItem component - }
\label{subpar:todo_app_bloc_core_state}

The TodoItem component does not need any modification with respect to the implementation reposrted HERE RIFERIMENTO. Indeed, it just receives a todo from the parent widget and exposes it to the user. The only missing part in the onChanged field of the Checkbox that is left empty because its implementation changes between diffent solutions. Inside the onChage field a function must be provided that updates the completed field of the todo visualized by the TodoView widget. Providing that function is really easy, the store is accessed using the of method of the StoreProvider widget. ( the of method gets the nearest instance of the store of type provided in the call, in our case AppState)The store is then used to dispatch an action of type SetCompletedTodoAction created using the id of the visualized todo and the completed Boolean value provided by the onChange fuction.

\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - state integration in the TodoItem component} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
Checkbox(
    value: todo.completed,
    onChanged: (completed) {
      StoreProvider.of<AppState>(context).dispatch(
          SetCompletedTodoAction(todo.id, completed!));
    }),
\end{minted}
\mbox{}
\end{code}

\paragraph{The VisibilityFilterSelector component - }
\label{subpar:todo_app_bloc_core_state}
The dfhdhfdhs component only accesses the part of the state concerning the filter. The entire DropdownButton widget is wrapped into a StoreConnector widget. The StoreConnector’s converter function will return a value of type VisibilityFilter. In the converter field a function taking the store and returning the filter value must be provided. To do so the filterSelector implemented earlier can be used or instead the filter value can be accessed directly by the store, both solution are equivalent. The ouput of the converter function can be accessed in the builder field function and used to populate the DropdownButton widget. The only part that differs from the implementation provided HERE RIFERIMENTO is the function used in the onChanged field of the DropdownMenuItem widgets. It gets an instance of the store using the StoreProvider widget’s of method and then dispatches an action of type SetVisibilityFilterAction using the DropdownMenuItem corresponding filter value.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - state integration in the VisibilityFilterSelector component} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@override
Widget build(BuildContext context) {
  return StoreConnector<AppState, VisibilityFilter>(
    converter: (store) => filterSelector(store.state),
    builder: (context, activeFilter) {
      print("Building Visibility filter");

      return DropdownButton<VisibilityFilter>(
        value: activeFilter,
        items: VisibilityFilter.values.map((filter) {
          return DropdownMenuItem<VisibilityFilter>(
              child: Text(describeEnum(filter)), value: filter);
        }).toList(),
        onChanged: (filter) {
          StoreProvider.of<AppState>(context)
              .dispatch(SetVisibilityFilterAction(filter!));
        },
      );
    },
  );
\end{minted}
\mbox{}
\end{code}

\paragraph{The TabSelector component - }
\label{subpar:todo_app_bloc_core_state}
Also in this case the TabSelector components needs to read and write the AppState. A StoreConnecgor widget is used to wrap the BottomNavigationBar widget making the state accessible to it. The view model to be outputted by the converter function is just an object of type TabState. An arrow function that returns the current AppState’s tab is provided to the converter field. The function output is then used in the builder field function to populate the BottomNavigationBar widget. To notice the function provided in the onTap field that accesses the AppState using the StoreProvider’s of method and dispatches a new action of type SetTabAction with the corresponding bottomNavigationBarItem’s teb value.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - state integration into TabSelector component} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class TabSelector extends StatelessWidget {
  const TabSelector({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {

    return StoreConnector<AppState, TabState>(
      converter:(store)=>store.state.tabState,
      builder: (context, currTab) {
        print("Building Tab Selector");

        return BottomNavigationBar(
          currentIndex: TabState.values.indexOf(currTab),
          onTap: (index)=>StoreProvider.of<AppState>(context).dispatch(SetTabAction(TabState.values.elementAt(index))),
          items: TabState.values
              .map((tab) => BottomNavigationBarItem(label: describeEnum(tab),
                    icon: Icon(
                      tab == TabState.todos ? Icons.list : Icons.show_chart,
                    ),
                  ))
              .toList(),
        );
      },
    );
  }
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The Stats component - }
\label{subpar:todo_app_bloc_core_state}
The stats component only needs to read the state. The Center widget is wrapped into a StoreConnector widget. In the converter field function the completedTodoSelector function is used to access the list of completed todos and its length is then computed. In this case ,indeed, the viewmodel to be outputted is just an int value. The int value is then displayed in the Text widget.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - state integration into Stats component} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class Stats extends StatelessWidget {
  const Stats({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return StoreConnector<AppState, int>(
      builder: (context, completed) {
        print("Building Stats");
        return Center(child: Text(completed.toString()));
      },
      converter: (store) {
        return completedTodosSelector(store.state).length;
      },
    );
  }
}
\end{minted}
\mbox{}
\end{code}

At this point all the base functionalities have been implemented and are working fine.
 

\subsubsection{Features addition}  \label{par:todo_app_inherited_widget_introduction}

As usual the first thing to do is to make the state provide a way of adding and updating todos. For this purpose two new action are created with the name AddTodoAction and UpdateTodoAction respectively. In the AddTodoAction the name and the description for the todo to be create are contained. In the UpdateTodoAction ,besides the new name and description for the todo, also the id of the todo to be modified is provided.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - AddTodoAction and UpdateTodoAction definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class AddTodoAction {
  final String name;
  final String desc;

  AddTodoAction(this.name, this.desc);
}

class UpdateTodoAction{
  final String name;
  final String desc;
  final int id;

  UpdateTodoAction(this.name,this.desc,this.id);
}
\end{minted}
\mbox{}
\end{code}

In order to handle these new actions two reducers must be created. They are called respectively addTodo and updateTodo and are just functions. They are inserted in the reducers of the list of todos. The addTodo reducer takes as argument the current list of todos and the AddTodoAction object. It first creates the new todo using the information contained in the action object and generating a new unique id. Then creates a completely new list and populates it with the old list elements and the new todo.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - AddTodoAction's reducer definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
List<Todo> _addTodo(List<Todo> todos, AddTodoAction action) {
  Random rand = Random();
  List<int> ids = todos.map((todo) => todo.id).toList();
  int newId = rand.nextInt(1000) + 2;
  while (ids.contains(newId)) {
    newId = rand.nextInt(1000) + 2;
  }
  Todo newTodo = Todo(
      id: newId,
      name: action.name,
      description: action.desc + " " + newId.toString(),
      completed: false);

  return List.from(todos)..add(newTodo);
}
\end{minted}
\mbox{}
\end{code}

The updateTodo reducer takes the current list of todo and an action of type UpdateTodoAction as arguments.  It first modifies the todoof the current list of todos with the id matching the one contained in the action. Then it generates a new list with the element contained in the current one and returns it.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - UpdateTodoAction's reducer definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
List<Todo> _updateTodo(List<Todo> todos, UpdateTodoAction action){

  List<Todo> newList= todos.map((todo) => todo.id == action.id
      ? Todo(
      id: action.id,
      name: action.name,
      description: action.desc,
      completed: todo.completed)
      : todo).toList();

  return List.from(newList);
}
\end{minted}
\mbox{}
\end{code}

These new reducers are then combined with the other existing ones in the combineReducers function and linked with the corresponding action using the type class TypedReducer.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - combining new reducers to the old ones} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final todoReducer = combineReducers<List<Todo>>([
  TypedReducer<List<Todo>, AddTodoAction>(_addTodo),
  TypedReducer<List<Todo>, LoadTodoSucceededAction>(_setLoadedTodo),
  TypedReducer<List<Todo>, SetCompletedTodoAction>(_setCompletedTodo),
  TypedReducer<List<Todo>, UpdateTodoAction>(_updateTodo),
]);
\end{minted}
\mbox{}
\end{code}

And that’s it, the AppState can now handle actions of type AddTodoAction and UpdateTodoAction. These new functionalities can now be used in the AddTodoPage and in the UpdateTodoPage easilt due to the fact that they can be accesses directly. The StoreProvider widget has been , indeed, positioned in the root of the application to be available in all the sub trees. The onPressed field ‘s function of the TextButton widget in the AddTodoPage dispatches an Action of type AddTodoAction in the AppState utilizing the name and description’s textControlled text field.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - using the AddTodoAction in the AddTodoPage} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
TextButton(
    onPressed: () {
      final AddTodoAction action= AddTodoAction(textControllerName.text, textControllerDesc.text);
      StoreProvider.of<AppState>(context).dispatch(action);
      Navigator.pop(context);
    },
    child: const Text("Create"))
\end{minted}
\mbox{}
\end{code}

And the same is done in the UpdateTodoPage dispatching an action of type UpdateTodoAction composed using the textControllers’s text values and the id of the todo passed as argument from the TodoItem widget.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - using the UpdateTodoAction into the UpdateTodoPage} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
TextButton(
    onPressed: () {
      final UpdateTodoAction action= UpdateTodoAction(textControllerName.text,textControllerDesc.text,widget.todo.id);
      StoreProvider.of<AppState>(context).dispatch(action);
      Navigator.pop(context);
    },
    child: const Text("Confirm"))
\end{minted}
\mbox{}
\end{code}

All the features have been successfully added and work well.
\subsubsection{Rendering optimization}  \label{par:todo_app_inherited_widget_introduction}

In order to perform the optimizations, we will leverage on the fact that the StoreConnector widgets only rebuilds when the viewmodel ,it relies on , changes. Or better, this behavior happens when a specific field of the StoreConnector widget ,called distinct, is set to true. This feature ,the redux package provides, makes the optimization process really easy. We just need to define the correct viewmodel and the correct equality operator between viewmodels. Some changes must be done in the TodoView widget and in the TodoItem widget. Firstly, the TodoItem widget needs to interact with the state to understand when a change regarding its todo is performed. For the moment , indeed ,the TodoItem widget just receives a todo instance from the parent widget and visualizes it. As usual, we use a StoreConnector widget to read the state in the TodoItem widget. The complete instance of the todo to be visualized is not necessary to be passed by the parent anymore but the id only is enough. Using the id , the corresponding todo is searched in the store by the converter field’s function and passed to the builder field. The widget returned by the builder function remains the same with the only exception that it uses the todo instance got from the store instead of the one passed by the parent widget. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - make the TodoItem component read the state} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class TodoItem extends StatelessWidget {
  final int id;

  const TodoItem({Key? key, required this.id})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return StoreConnector<AppState, Todo>(
      distinct: true,
        converter: (store) =>
            store.state.todos.firstWhere((element) => element.id == id),
        builder: (context, todo) {
          print("building: Todo Item \$id ");

          return InkWell(. . .);
        });
  }
}
\end{minted}
\mbox{}
\end{code}

Now that the TodoItem widget watches for its own todo changes ,the optimization process regarding the TodoItem widget is automatically performed. We said, indeed, that the Storeconnector widget is rebuilt every time its viewmodel changes and we set the viewmodel as the corresponding todo instance in the AppStore. Once a state change occurs, the StoreConnector widget compares the current todo with the new one and, in case they differ, it rebuilds. To notice that this mechanism works because we redefined the equality operator between objects of type Todo HERE RIFERIMENTO. An object of type Todo is equal to another one if all their internal values match. This equality differs from the traditional one by the fact that do not check for the entity’s equality. Indeed, if it would, the two todos would appear to be different everytime. This because every time a new state is emitted the list of todos is recreated from scratch and   also its internal todos are. In the dart language two different objects end to be different also if their internal values are exactly the same. This way of handling object already showed up numerous times in this overview and will show up even more in the next implementations. Going back to the to the TodoItem component , it already uses the correct equality operator to compare different viewmodels and so is capable to understand when to rebuild by itself. The same process must be done in the TodoView widget. It already uses a StoreConnector widget but in the converter function derives the list of filtered todos from the store. However, as we just said, two plain lists appear to be always different by default. Moreover, it is not possible to redefine the equality operator for list and in every case it would not be a good idea. A simple way to handle this scenario is to create ad hoc viewmodel and refine its equality operator in order to implement our own rebuilding logic. To do so a local class is created and called ViewModel. This local class just contains a list of todos.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - TodoView ad hoc ViewModel definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class _ViewModel {
  final List<Todo> todos;

  _ViewModel({required this.todos});

}
\end{minted}
\mbox{}
\end{code}

 Inside the ViewModel class the equality operator is overridden making two ViewModel instances equal when their length matches and their internal ids match too. In this way the TodoView widget is rebuild only in case the filtered todos list has reported a structural change. (structural and not structural changes are exaplained HERE RIFERIMENTO). 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - ViewModel equality operator override} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
  @override
  bool operator ==(Object other) {
    return ((other is _ViewModel) &&
        todos.length == other.todos.length &&
        todos.every(
            (todo) => other.todos.any((element) => todo.id  == element.id)));
  }

  @override
  // TODO: implement hashCode
  int get hashCode => todos.hashCode;
\end{minted}
\mbox{}
\end{code}

After setting the distinct field to true and modifying the converter function to return a ViewModel instead of a plain List the optimizations are basically done.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - Redux - TodoView renders optimization} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class TodoView extends StatelessWidget {
  const TodoView({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return StoreConnector<AppState, _ViewModel>(
        distinct: true,
        builder: (context, vm) {
          print("Building TodoView");
          return ListView.builder(
            itemCount: vm.todos.length,
            itemBuilder: (context, index) {
              return TodoItem(
                id: vm.todos.elementAt(index).id,
              );
            },
          );
        },
        converter: (store) {
          return _ViewModel(todos: filteredTodosSelector(store.state));
        });
  }
}
\end{minted}
\mbox{}
\end{code}

To put the  the icing on the cake we set the distinct field to true also in the VisibilityFilterSelector compoenent and in the TabSelector component. In this way they are rebuilt only in case their prospective of the state changes and not at every transition.

\subsubsection{Conclusions} \mbox{} \\
\label{subpar:render_optimizations_inherited_widget}
\begin{table}[H]
    \caption*{\textbf{Recap}}
    \centering 
    
    \begin{tabular}{| l | c | c | c |}
    \hline
    \rowcolor{bluepoli!40} % comment this line to remove the color
    \hline
     & \textbf{lines of code} & \textbf{time} & \textbf{classes} \T\B \\
    \hline
    \textbf{base functionalities} & 156 & 9-11 h & 6 \T\B \\ 
    \textbf{feature addition} & 50 & 15-20 m & 2 \T\B\\ 
    \textbf{rendering optimization} & 28 & 1 h & 1
    \T\B\\
    \hline
    \end{tabular}
    \\[10pt]
    \caption{Caption of the Table to appear in the List of Tables.}
    \label{table:example}
\end{table}

\begin{figure}[H]
 \caption*{\textbf{Hours}}
\centering
\begin{tikzpicture}

\pie[rotate = 60]{
    88.2/Base functionalities ,
    3/Feature addition,
    8.8/Optimizations 
    }

\end{tikzpicture}
 \caption{Caption of the Table to appear in the List of Tables.}
\end{figure}
\begin{figure}[H]

\caption*{\textbf{Lines}}
\centering
\begin{tikzpicture}

\pie[rotate =90]{57.3/Structure - 314,
    29.5/Base functionalities - 367,
    9.12/Feature addition - 67,
    5.11/Optimizations - 33
    }
 
\end{tikzpicture}
 \caption{Caption of the Table to appear in the List of Tables.}
\end{figure}
