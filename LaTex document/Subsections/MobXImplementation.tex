Here start the implementation process that utilizes the MobX state management solution.

\subsubsection{Base funtionalities}  \label{par:todo_app_inherited_widget_introduction} 
 
As mentioned in the Chapter XX RIFERIMENTO the MobX package makes part of the state Observable and uses a particular widget, called Observer, to keep track of changes in the observed variables. To be able to define observables is necessary to extend the intrested class with the Store class offedered by the package. Moreover, the container class must be made abstract. The usual definition of the Todo class is used momentarily remembering that no rendering optimizations are kept into account. The parts of the state to be made observable are: the list of todos , the filter and the tab value. The whole application, indeed, relies on them to track changes and update correspondingly. 
\paragraph{The observable state - }
\label{subpar:todo_app_bloc_core_state}A new abstract class is created and called \_TodoStore. It contains the list of todos and the filter. A separate observable variable will be used to implement the state of the tab. This design choice allows to show two different approaches the MobX package provides and divides the information regarding the todos from the information regarding the tab value. ( the filter value is in some way connected with the list of todo). This new abstract class is extended with the Store class. A list of todos and a visibility filter are created inside it and annoted with the @observable syntax. The @observable annotation informs the code generator that those variables need to be made observable, moreover, the code generator automatically creates a getter and a setter action for them. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX- TodoStore abstract class definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
abstract class _TodoStore with Store {
  @observable
  List<Todo> todos = [];

  @observable
  VisibilityFilter filter = VisibilityFilter.all;
}
\end{minted}
\mbox{}
\end{code}

\paragraph{Actions - }
\label{subpar:todo_app_bloc_core_state}In this implementation the strict mode is set to “always”. This choice reflects the common usage of the pattern. It is indeed a common choice to allow state mutations only through actions. This behavior comes with a lot of advantages that make it the correct choice for the major of the cases. This subject will be deeper investigated in the latter sections but, for the moment , it is worth noting that the mobx package also provides the possibility to configure the strict mode to “never”  allowing to directly change the state without passing through an action.  A bunch of new methods are added to the TodoStore class and marked with the @action annotation. The simplest one is the \textit{changeFilter} method that allows to change the current filter.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - TodoStore's changeFilter action definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart} 
 @action
  void changeFilter(VisibilityFilter filter) {
    this.filter = filter;
  }
\end{minted}
\mbox{}
\end{code}

A method to set the \textit{completed} field of a particular todo is also required. This method is called \textit{setCompleted} and takes the id of the todo to be changed and its new completed value. As usual , a new list is created, after modifying the todo, in order to allow mobx to recognize the change in the list of todos.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - TodoStore's setCompleted action definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
  @action
  void setCompleted(int id, bool completed) {
    assert(todoExists(id) != null, 'No todo with id : \$id');
    todos.where((element) => element.id==id).first.completed=completed;
  }

Todo? todoExists(int id) {
  List<Todo> result = todos.where((element) => element.id == id).toList();
  return result.isNotEmpty ? result.first : null;
}
\end{minted}
\mbox{}
\end{code}

The two usual methods to fetch and save the todos into the DataBase/repository are implemented and annotated with the @action annotation too.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - TodoStore's fetchTodos and saveTodos actions definitions} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@action
Future<void> fetchTodos() async {
  todos = await TodoRepository.loadTodos();
}

@action
Future<void> saveTodos() async {
  await TodoRepository.saveTodos(todos);
}
\end{minted}
\mbox{}
\end{code}

\paragraph{Computed fields - }
\label{subpar:todo_app_bloc_core_state}computed fields are the part of the state that can be derived from other parts of the state. They are pivotal in the mobx state management solution because the package is able to smartly compute them and to perform lot of optimizations under the hood using memoization technique to prevent useless computations. They are a similar concept with respect to selector in Redux. The list of completed todos is well suited to demonstrate the power of the computed field. A new getter function is created and called \textit{completedTodos}. It computes the list of completed todos and returns it. The @computed annotation is positioned right above the method to make the code generator know how to implement it in order to perform the optimizations discussed earlier. During the application lifecycle the \textit{completedTodos} method will be accessed numerous times and automatically recomputed in case a part of the state, it depends on, changes. Moreover, its value is memoized and reused in case multiple accesses are necessary. Another method is created in the same way to compute the \textit{pendingTodos}.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - TodoStore's completedTodos and pendingTodos computed values definitions} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@computed
List<Todo> get completedTodos =>
    todos.where((element) => element.completed).toList();

@computed
List<Todo> get pendingTodos =>
    todos.where((element) => !element.completed).toList();
\end{minted}
\mbox{}
\end{code}


\textit{pendingTodos} and \textit{completedTodos} methods are then used to implement other computed values: the \textit{filteredTodos}, the number of completed todos and the number of pending todos. The \textit{filteredTodos} method returns the list of todos that match the visibility filter. It is composed using the computed values defined before. Also the \textit{stats} value can be obtained using the computed feature.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - filteredTodos and stats computed value definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@computed
List<Todo> get filteredTodos {
  switch (filter) {
    case VisibilityFilter.all:
      return todos;
    case VisibilityFilter.completed:
      return todos.where((element) => element.completed).toList();
    case VisibilityFilter.notCompleted:
      return todos.where((element) => !element.completed).toList();
  }
}

@computed
int get len => todos.length;

@computed
int get completed => completedTodos.length;

@computed
int get pending => pendingTodos.length;

@computed
String get stats {
  return completed.toString();
}
\end{minted}
\mbox{}
\end{code}

\paragraph{The code generation - }
\label{subpar:todo_app_bloc_core_state}The \_TodoStore class won’t be directly used in the code but its actual implementation will. The \_TodoStore is, indeed, an abstract class and is used by the code generator to implement the actual TodoStore class. A particular line of code must be placed just below the imports to allow the code generator to recognize the abstract class to implement. This line of code uses the "part" syntax followed by the name of the file to be generated. The generated code will be putted inside a file called counter.g.dart which is included with the part directive right below the imports. Without this line, the code generator will not produce any output. The generated file contains the \_\$TodoStore mixin. It is combined with the \_TodoStore abstract class to finally implement the TodoStore.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - TodoStore code generation} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
part 'todo_store.g.dart';

class TodoStore = _TodoStore with _\$TodoStore;
\end{minted}
\mbox{}
\end{code}

In order to use the code generator and generate the code, a series of directives can be used into the terminal. For the sake of simplicity, the following line of code will be always used to generate code.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - code generator directives} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
flutter pub run build_runner watch --delete-conflicting-outputs
\end{minted}
\mbox{}
\end{code}

It automatically generates the code and handles all the possible conflicts that can arise. For example, in case a file named todo\_store.g.dart already exists it first deletes the file and then computes it again. With this line of code, the code generation process is made really easy. The drawback is that every time the code must be modified it is generated from scratch instead. In our case is not a big deal because the application is contained and the code generator only takes about 12-13 seconds to execute and generate the entire code. In a more spread scenario other directives can be used to make the code generation process lighter. I decided not to show the generated code because it is quite long and hard to read.

\paragraph{The spy feature - }
\label{subpar:todo_app_bloc_core_state} in order to enable the spy feature a new configuration for the \textit{mainContext} must be provided before running the application, in the main function. After cloning the default \textit{mainContext} the \textit{isSpyEnabled} field is set to true and the \textit{writePolicy} is set to always in order to enable the strict-mode for every state change. Moreover, a function must be passed to the spy feature. The code inside this function is execute every time a action occurs. It is, indeed, possible to perform arbitrary actions when events occurs. In our case is enough to print the event name when an event of type action occurs to have a clearer picture of what is going on.

\begin{code}
\mbox{}
\captionof{listing}{Todo app - MobX - spy feature attachment} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
mainContext.config = mainContext.config
    .clone(isSpyEnabled: true, writePolicy: ReactiveWritePolicy.always);
mainContext.spy((event) {
  if (event.type == "action") {
    print("event name : " + event.name);
  }
});
\end{minted}
\mbox{}
\end{code}


And that’s basically all we need in order to implement the application’s state. At this point is indeed already possible to test the state logic.

\paragraph{Making the state accessible - }
\label{subpar:todo_app_bloc_core_state} MobX, like every other solution used so far, uses a provider widget to supply the state to the subtree. In this case the mobx package do not self-implement the provider widget, instead it relies on and external package called \textit{Provider} which offers this feature. The procedure is the usual one, the MaterialApp widget is wrapped into a Provider widget of type TodoStore which supplies the instance of the TodoStore to the subtree. It has a \textit{create} field where the TodoStore can be initialized and where the fetching of todos can take place.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - dispatch TodoStore using Provider widget} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
return Provider<TodoStore>(
    create: (_) => TodoStore()..fetchTodos(),
    child: MaterialApp(. . .),
    }));
\end{minted}
\mbox{}
\end{code}



\paragraph{The HomePage and the TabSelector component - }
\label{subpar:todo_app_bloc_core_state}The HomePage is almost entirely built using the state's part regarding the tab. The first thing to do is to create an observable variable of type TabState to represent it. This time, a different approach with respect to the one used to implement the state of the todos and the filter, is used. We are not creating an abstract class neither generating any code. Moreover, no Provider widget is used because the tab value needs to be accessed only in a couple of widgets and passing it between them is way easier. The tab value is wrapped into an observable object of type TabState. The entire object is managed by the MobX package and the only difference with respect to a normal variable usage is that, in order to access the TabState value, we need to further dig into the \textit{value} field instead of just using the tab variable as it is. Both the body and the VisibilityFilterSelector as well as the TabSelector depends on the tab value so the entire Scaffold widget is wrapped into a Observer widget. Once a change in the \textit{tab} variable occurs, the Observer widget automatically determine which parts of the Scaffold widget should be rebuilt. In our case all components depends on the tab value and then every component is rebuilt once a tab change occurs. In cases some component are independent from the tab value and are wrapped into the observer widget they would not be rebuilt. The entire Scaffold is populated using the tab variable as usual. The only part that differs is the TabSelector component. Beside depending on the tab value it also need to change it. There are two equivalent options : passing the tab variable to the TabSelector component or passing a closure function. The first solution is used. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - HomePage implementation} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class HomePage extends StatelessWidget {
  HomePage({Key? key}) : super(key: key);
  final _tab = Observable<TabState>(TabState.todos);

  @override
  Widget build(BuildContext context) {
    print("building HomePage");
    return Observer(
      builder: (context) {
        return Scaffold(
          appBar: AppBar(. . .),
          body: _tab.value == TabState.todos ? const TodoView() : const Stats(),
          bottomNavigationBar: TabSelector(
            tab: _tab,
          ),
          floatingActionButton:  _tab.value == TabState.todos
                ? FloatingActionButton(. . .)
                : Container()
        );
      }
    );
  }
}
\end{minted}
\mbox{}
\end{code}

A new variable is added to the TabSelector widget and populated in the constructor. It is used in the \textit{onTap} field’s function to mutate the tab value once the user taps on one specific BottomNavigationBarItem. Notice that the state change is wrapped into a \textit{runInAction} object. This because if we change the tab value directly, a run time error would arise alerting that observable values cannot be changed outside actions. This is due to the strict mode previously set to "always". \textit{runInAction} creates a throwaway action we can use directly in the code. This approach is made necessary because we used a stand alone Observable variable. If we included the tab variable into the TodoStore class the code generator would had automatically create also its getter and setter actions.


\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - TabSelector component implementation} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}

class TabSelector extends StatelessWidget {
  final Observable<TabState> tab;

  const TabSelector({Key? key, required this.tab}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    print("building TabSelector");

      return BottomNavigationBar(
        currentIndex: TabState.values.indexOf(tab.value),
        onTap: (index) {
          runInAction(() => tab.value = TabState.values.elementAt(index));
        },
        items: (...),
      );

  }
}
\end{minted}
\mbox{}
\end{code}
\paragraph{The VisibilityFilterSelector component - }
\label{subpar:todo_app_bloc_core_state}It entirely depends on the value of the filter in the TodoStore. To obtain the instance of the TodoStore we use the static \textit{of} method of the Provider widget specifying the type of the instance we are looking for. This procedure will be frequently used from now on and is usually performed at the beginning of the \textit{build} method. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - retrieving the TodoStore} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final store = Provider.of<TodoStore>(context);
\end{minted}
\mbox{}
\end{code}

The entire VisibilityFilterSelector component is then populated using the filter  variable contained in the TodoStore as usual and wrapped into an Observer widget to make is responsive to filter changes. In the \textit{onChanged} field of the DropdownMenuItem widgets the \textit{changeFilter} action previously defined is used to
set the filter value to the tapped one.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - VisibilityFilterSelector component implementation} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
return Observer(
  builder: (context) {
    print("building Visibilityfilter");

    return DropdownButton<VisibilityFilter>(
      value: store.filter,
      items: (...),
      onChanged: (tappedValue) {
        store.changeFilter(tappedValue!);
      },
    );
  },
);
\end{minted}
\mbox{}
\end{code}

Notice that we could omit the usage of the \textit{changeFilter} action and set the value of the filter directly. This because a setter and a getter action are automatically created by the code generator for every observable field. This implies that the \textit{changeFilter} action could also be omitted in the definition of the TodoStore abstract class.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - changing the state in the VisibilityFilterSelector without predefined action} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
onChanged: (tappedValue) {
        store.filter = tappedValue!; 
      },
\end{minted}
\mbox{}
\end{code}

I personally dislike this feature MobX offers in the Flutter framework. I investigated a bit in the usage of MobX with React and JS finding that, in that case, it behaves as expected raising a warning in case a field is directly changed. (violating the strict mode) I find the way of changing the filter value proposed in the Source Code RIFERIMENTO a lot more elegant with respect to the one proposed in the Source Code RIFERIMENTO. Explicitly using predefined actions, indeed, brings way more meaning for the reader and prevents programmers to accidentally mutate the state in the implementation process. Even if I prefer the first approach, in the end , both approaches pass though actions in order to change the state and this respect the MobX approach. Actions are, indeed, really important to the correct functioning of the application because using them allow the mobx package to generate atomic state transitions. Suppose a simple action, like the one we just used , produces reactions of different types and those reactions affects different parts of the state and the UI. Suppose now that the strict mode is disabled and set to "never". In that case can happen that the various reactions are completed/fired in different interval of time because their carried computation is heavier of lighter with respect of the others. Consequently the entire state of the application is not well synchronized and the UI could reflect this inconsistency bringing to a bad situations. Mobx package ensure that actions, and consequent reactions, are performed atomically without leaking any intermediate values as long as actions are used.
\paragraph{The Stats component - }
\label{subpar:todo_app_bloc_core_state} this component is really simple. It just needs to access the TodoStore to get the \textit{stats} value. The procedure shown in the Source Code RIFERIMENTo is used as usual to get an instance of the TodoStore and, consequently, of the \textit{stats} value. The entire widget is then wrapped into an Observer widget .
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - Stats component implementation} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final store = Provider.of<TodoStore>(context);
return Observer(
  builder: (context) {
           return Center(child: Text(store.stats));
  },
);
\end{minted}
\mbox{}
\end{code}
\paragraph{The TodoView component and the TodoItem component - }
\label{subpar:todo_app_bloc_core_state} These two components represent the core of the UI development process. Remember now that no optimizations are considered for the moment. The TodoView widget needs to access the state and rerender once a change in the filteredList of todos occurs. In this scenario, the MobX pattern really shines. It is sufficient to wrap the entire TodoView widget inside a Observer widget and access the filtered list of todo contained in the TodoStore to allow the MobX package to automatically detect a change in the filtered list. Once the list of todos or the filter is updated, the \textit{filteredList} is automatically computed. As usual the TodoItem widget just acts as a visualizer for the corresponding todo and consequently takes as argument the todo instance to be visualized.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - TodoView component implementation} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
final store = Provider.of<TodoStore>(context);
return Observer(
  builder: (_) {
    print("building TodoView");

    return ListView.builder(
      itemCount: store.filteredTodos.length,
      itemBuilder: (context, index) {
        return TodoItem(
          todo: store.filteredTodos.elementAt(index),
        );
      },
    );
  },
);
\end{minted}
\mbox{}
\end{code}

The TodoItem widget implementation is the same presented HERE RIFERIMENTo except for the \textit{onChanged} field of the TextButton widget that needs to be filled up. The provided function retrieves the store using the Provider widget and fires the \textit{setCompleted }action using the todo’s id and the new value for the completed field. Notice, that also in this case the \textit{completed} field could be changed directly without any error.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - changing the state in the TodoItem component's Checkbox} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
onChanged: (value) {
  final store = Provider.of<TodoStore>(context);
  store.setCompleted(todo.id, value!);
  // the state could also be changed using
  // todo.completed = value!;
}),
\end{minted}
\mbox{}
\end{code}

The base functionalities are now working fine.
\subsubsection{Features addition} \mbox{}\\ \label{par:todo_app_inherited_widget_introduction}In order to add and update todos its necessary to define two new actions. Also in this case the creation of these two new actions could be avoided because setter and getter methods already exists for the list of todos. However , actions carry a lot more meaning and enable to avoid code duplication. Two new methods are added to the TodoStore class and annoted with the @action syntax. The functioning is the usual one, in the \textit{addTodo} method a new todo instance is created with an unique id and added to the list of todos. In the \textit{updateTodo} method the id argument is used to search for the corresponding todo and the \textit{name} and \textit{desc} arguments are used to update it. Both methods need to substitute the todo’s list with a new instance to allow the MobX package to recognize the change. Subsequently the code is generated again using the line of code presented HERE RIFERIMENTO.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - updateTodo and addTodo actions definition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
@action
void updateTodo(int id, String name, String desc) {
  assert(todoExists(id) != null, 'No todo with id : \$id');
  Todo todo=todos.where((element) => element.id==id).first;
  todo.name=name;
  todo.description=desc;
}

@action
void addTodo(String name, String desc) {
  Random rand = Random();
  List<int> ids = todos.map((e) => e.id).toList();
  int newId = rand.nextInt(1000) + 2;
  while (ids.contains(newId)) {
    newId = rand.nextInt(1000) + 2;
  }
  Todo newTodo = Todo(
      id: newId,
      name: name,
      description: desc + " " + newId.toString(),
      completed: false);

  todos.add(newTodo);
  todos = todos.toList();
}
\end{minted}
\mbox{}
\end{code}

Accessing these new actions in the UpdateTodoPage and in the AddTodoPage is simple by the fact that the Provider widget has been positioned as parent of the MaterialApp widget (from where different routes generate). In the \textit{onPressed} field of the TextButton, situated in the AddTodoPage, the store is retrieved using the Provider’s \textit{of} method and used to fire a action of type addTodo. 
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - AddTodoPage implementation} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
onPressed: () {
  final store =
      Provider.of<TodoStore>(context, listen: false);
  store.addTodo(
      textControllerName.text, textControllerDesc.text);
  Navigator.pop(context);
}
\end{minted}
\mbox{}
\end{code}

The same is done for the \textit{onPressed} field of the TextButton in the UpdateTodoPage.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - UpdateTodoPage implementation} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
onPressed: () {
  final store =
      Provider.of<TodoStore>(context, listen: false);
  store.updateTodo(widget.todo.id, textControllerName.text,
      textControllerDesc.text);
  Navigator.pop(context);
},
\end{minted}
\mbox{}
\end{code}

\subsubsection{Rendering optimizations} \mbox{}\\ \label{par:todo_app_inherited_widget_introduction}
Mobx package allows to perform the optimizations in an easy and direct way. All the effort is taken by the packages itself and the only thing to be cared about is to fragment the state in the most suited granularity for the purpose. In other words it is sufficient to make the state observable in the right points and wrap the corresponding UI elements into Observer widgets to get the job done. In the implementation provided so far for the list of todos, the only observable part was the list itself. The list is observed by the package and by the Observer widget contained in the TodoView. There is no concept of observability in the single todos yet and , once an instance of todo is change, what is seen by the package is just a completely new list. Consequently , every Observer widget listening for changes in the todo list is rebuilt. The smallest observable element the package sees is the list itself. Said that, the first thing to do in order to optimize the renderings is to increase the granularity of the observed state. Not the list only but also every contained todo needs to be made observable. It is necessary tough to redefine the todo model. This necessity arises with the usage of the mobx package and has not been faced in the other state management solutions used so far. The mobx state management solution introduces a dependency also in the data layer and in the model definition beside the usual dependency introduced in the business logic layer. In some scenarios this could represent an untoward drawback, for example in the porting processes. The Todo model class need to be made abstract an to implement the Store behaviour as we did for the TodoStore. Now it is possible to annotate its internal fields with the @action syntax. All the fields except the id need to be observable. Moreover, the final attribute must be removed to all the observed variables. It is indeed meaningless to observe a variable that cannot be mutated.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - Todo model redefinition} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
part 'todo.g.dart';


class Todo = _Todo with _\$Todo;

abstract class _Todo with Store{

   final int id;
  @observable
   String name;
  @observable
   String description;
  @observable
   bool completed;
(…)
}
\end{minted}
\mbox{}
\end{code}

Using the line of code presented HERE RIFERIMENTO the todo.g.dart file is generated. The TodoItem widget is “stateless” for the moment. It receives a copy of the corresponding todo instance from the parent. We need to retrieve the instance directly from the store if we want the Observer widget to rebuild correctly and react to changes. Instead of receiving the entire todo from the parent the id field is enough. It is used then in the build method to access the corresponding todo instance in the store using the Provider widget. The remaining TodoItem code remains the same except for the fact that it is wrapped into an Observer widget.
\begin{code}
\mbox{}\\
\captionof{listing}{Todo app - MobX - Making the TodoItem responsive to state changes} \mbox{}
		\label{code:2.14}
\begin{minted}{dart}
class TodoItem extends StatelessWidget {
  final int id;

  const TodoItem({Key? key, required this.id}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final store = Provider.of<TodoStore>(context, listen: false);
    final todo = store.todos.where((element) => element.id == id).first;
    return Observer(builder: (_) {
      print("building TodoItem \${todo.id}");

      return InkWell(…);
    });
  }
}
\end{minted}
\mbox{}
\end{code}

\subsubsection{Conclusions} \mbox{}\\ \label{par:todo_app_inherited_widget_introduction}
\begin{table}[H]
    \caption*{\textbf{Recap}}
    \centering 
       \begin{tabular}{| l | c | c | c |}
    \hline
    \rowcolor{bluepoli!40} % comment this line to remove the color
    \hline
     & \textbf{lines of code} & \textbf{time} & \textbf{classes} \T\B \\
     \hline
    \textbf{base functionalities and understanding} & 92 (+106) & 5-6 h & 2 (+1) \T\B \\ 
    \textbf{feature addition} & 31 (+45) & 10-15 m & 0 \T\B\\ 
    \textbf{rendering optimization} & 16 (+ 55) & 30 m & 1 (+1) \B\\
    \hline
    \end{tabular}
    \\[10pt]
    \caption{Caption of the Table to appear in the List of Tables.}
    \label{table:example}
\end{table}

\begin{figure}[H]
 \caption*{\textbf{Hours}}
\centering
\begin{tikzpicture}

\pie[rotate = 30]{
    88.0/Base functionalities ,
    4.0/Feature addition,
    8.0/Optimizations 
    }

\end{tikzpicture}
 \caption{Caption of the Table to appear in the List of Tables.}
\end{figure}

\begin{figure}[H]
\caption*{\textbf{Lines}}
\centering
\begin{tikzpicture}

\pie[rotate =0 ]{
	69.3/Structure - 314,
    20.3/Base functionalities - 92,
    6.8/Feature addition - 31,
    3.5/Optimizations - 16
    }
 
\end{tikzpicture}
 \caption{Caption of the Table to appear in the List of Tables.}
\end{figure}



\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{Images/struttura_cartelle_mobx.png}
    \caption{Show the tree structure after the FloatingActionButton in the HomePage is tapped.}
    \label{fig:add_todo_page_tree_structure}
\end{figure}
Down below some images taken from an execution of the application. In this execution ,six todos are randomly created and only two of them are marked as completed. 

\begin{figure}[H]
    \centering
    \subfloat[todos tab runtime UI.\label{fig:todos_tab_UI}]{
        \includegraphics[scale=0.6]{Images/albero_mobx_todos.png}
    }
    \quad
    \subfloat[todos tab runtime widget tree.\label{fig:todos_tab_tree}]{
        \includegraphics[scale=0.6]{Images/albero_mobx_stats.png}
    }
    \caption{Show the runtime Widget's tree and UI when visualizing todos tab.}
    \label{fig:todos_tab}
\end{figure}


Figure~\ref{fig:todos_tab_UI} shows how the application's UI looks like after few seconds from the start. Figure~\ref{fig:todos_tab_tree} show the widget's tree related with the run. Notice the TodoInheritedData widget as a child of the HomePage widget,it provides the state to the subtree.
